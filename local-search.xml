<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>红黑树总结</title>
    <link href="/2020/11/28/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/2020/11/28/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote><p>什么是二叉查找树（BST）？</p><ol><li><p><strong>左</strong>子树上所有结点的值均<strong>小于或等于</strong>它的根结点的值</p></li><li><p><strong>右</strong>子树上所有结点的值均<strong>大于或等于</strong>它的根结点的值。</p></li><li><p>左、右子树也分别为二叉排序树。</p><p>基于二分查找建树。但存在插入之后节点不平衡情况，由此引入红黑树。</p></li></ol></blockquote><p>红黑树是一种自平衡的二叉查找树，其具有如下特性：</p><ol><li>节点是红色或黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点（NIL节点）。</li><li>每个红色节点的两个子节点都是黑色。即从叶子到根不可能有两个连续的红色节点</li><li>从任意节点到其每个叶子的所有路径都包含相同数目黑色节点。</li></ol><p>典型红黑树如图：</p><p><img src="/img/hongheishu.png"> </p><p>由上述构建规则限制，保证了红黑树从根到叶子的最长路径不会超过最短路径的2倍。</p><h2 id="红黑树的调整"><a href="#红黑树的调整" class="headerlink" title="红黑树的调整"></a>红黑树的调整</h2><p>当插入和删除节点时，红黑树规则会被打破，此时要对其进行调整，以满足条件。调整有两种方法：<strong>变色</strong>和<strong>旋转</strong>，而旋转又分为左旋转和右旋转。</p><h3 id="红黑树的左旋和右旋"><a href="#红黑树的左旋和右旋" class="headerlink" title="红黑树的左旋和右旋"></a>红黑树的左旋和右旋</h3><p>左旋即<strong>逆时针</strong>旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子，如图：</p><p><img src="/img/hongheishuzuoxuan.png"></p><p>右旋即<strong>顺时针</strong>旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。如图：</p><p><img src="/img/hongheishuyouxuan.png"></p><p> 实际使用中，变色和旋转视情况混合使用。</p><h3 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h3><p>在JDK的集合类TreeMap和TreeSet底层都是红黑树实现。在Java8中，HashMap也用到了红黑树.</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对偶</title>
    <link href="/2020/11/27/%E5%AF%B9%E5%81%B6/"/>
    <url>/2020/11/27/%E5%AF%B9%E5%81%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="不定期更新的闪耀时刻"><a href="#不定期更新的闪耀时刻" class="headerlink" title="不定期更新的闪耀时刻"></a>不定期更新的闪耀时刻</h1><p>南风过境/梦至西洲</p><p>三山时春/四水常在</p><p>扁舟子/明月楼</p><p>轻云蔽月/流风回雪</p><p>花酿酒/水煎茶</p><p>家人闲坐，灯火可亲。</p><p>塞北风沙酒，江南烟雨桥。</p><p>玉在山而草木润，渊生珠而崖不枯。</p><p>冬月新落雪，徐步纳子岁。</p><p>投入亡地然后存，陷入绝处而后生。</p><p>为众人抱薪者，不可使其扼于风雪。</p><p>欢声笑语别枝后，漫天星子正少年。</p><p>大梦谁先觉，平生我自知。</p><p>青天有月来几时，我今停杯一问之。</p><p>长安陌上无穷树，唯有垂杨管别离。</p><p>敬这大争之世，敬这小酌之时。</p><p>虹贯荆卿之心，碧化苌弘之血。</p><p>时日低矮而天下羊白</p><p>水清鱼读月，花静鸟谈天。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java垃圾回收机制</title>
    <link href="/2020/11/27/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/11/27/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>GC虽然已经自动帮我们完成清理，但了解一下java垃圾回收机制，还是对我们性能调优，问题排查等有很大帮助。本文为博主阅读网上资料后做的相关整理。</p><h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><p>1.虚拟机栈：每个方法被执行的同时会创建<strong>栈桢</strong> ，要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机都很明确，此处<strong>不需要进行 GC</strong>。</p><p>2.本地方法栈：虚拟机栈为虚拟机执行 Java 方法时服务，本地方法栈为虚拟机执行本地方法时服务，此处也<strong>不需要进行 GC</strong>。</p><p>3.程序计数器：线程独有。可以看作是当前线程执行的字节码的行号指示器。Java虚拟机的多线程是通过线程轮流切换并分配处理器的时间来完成的。在任何一个时刻，一个处理器只会执行一个线程，如果这个线程被分配的时间片执行完了（线程被挂起），处理器会切换到另外一个线程执行，程序计数器即记录唤醒线程时上次执行到的位置。另外<strong>程序计数器是唯一一个 Java 虚拟机规范中没有规定任何 OOM 情况的区域</strong>。此处也<strong>不需要进行 GC</strong>。</p><p>4.本地内存：即堆外内存，包含元空间和直接内存，JAVA8之后此区域也<strong>不需要进行 GC</strong>。</p><p>5.堆：对象实例和数组都是在堆上分配，GC主要针对这些数据进行回收，<strong>堆是java垃圾回收处理的主要区域</strong>。</p><h1 id="系统垃圾识别"><a href="#系统垃圾识别" class="headerlink" title="系统垃圾识别"></a>系统垃圾识别</h1><p>GC如何判断堆中对象实例等是不是垃圾？</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>为对象添加引用次数属性，被引用一次，即加一。未被引用即为0，代表可被回收。</p><p>但此类无法解决循环引用的问题，在互相被引用的对象要求释放时，因为引用次数不为零，造成无法回收。因此此方法用得较少。</p><h2 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h2><p>利用一个GC Root的对象为起点出发，逐步指向下一个可达的节点，直至所有节点遍历完毕，不在生成的这个引用链上的对象，即被判断为垃圾，会被GC回收。</p><p>另外，不是a, b 对象可回收，就一定会被回收。对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收。且<strong>finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收。</strong></p><blockquote><p>GC Root是什么？哪些对象可作为GC Root？</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul></blockquote><h1 id="垃圾回收主要方法"><a href="#垃圾回收主要方法" class="headerlink" title="垃圾回收主要方法"></a>垃圾回收主要方法</h1><p>通过可达性算法识别了哪些数据是垃圾，如何对垃圾进行回收？主要有以下三种方法。</p><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><ol><li><p>根据可达性算法标记出所有的可回收对象</p></li><li><p>对可回收对象进行回收</p></li></ol><p>此种算法回收之后会造成很多零碎的小内存，不能满足连续内存的需要</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ol><li><p>将堆分为两块区域,A,B,区域A分配对象，B不分配对象</p></li><li><p>对A使用标记法把存活的对象都标记出来，并将它们复制到区域B</p></li><li><p>把A中对象全部清理释放空间</p></li></ol><p>此方法解决了内存碎片的问题，缺点是堆空间大小利用率大大降低，复制也有资源浪费。</p><h2 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h2><ol><li><p>根据可达性算法标记出所有的可回收对象</p></li><li><p>对标记对象进行整理，将所有存活对象都往一端移动，紧密排列</p></li><li><p>清除掉另一端所有非存活对象</p></li></ol><h1 id="当前垃圾回收器对比"><a href="#当前垃圾回收器对比" class="headerlink" title="当前垃圾回收器对比"></a>当前垃圾回收器对比</h1><p>说完了垃圾回收的方法论，到了垃圾回收器就是内存回收的具体实现了，当前垃圾回收器按使用时期分为如下几类：</p><blockquote><p>JVM中的堆，一般分为三部分：新生代，老年代，永久代（JAVA8永久代移除，被元空间取代）</p><p>1.何为新生代？</p><p>主要用来存放新生对象，一般占堆空间的三分之一空间，会频繁创建对象，频繁触发GC进行垃圾回收。</p><p>新生代又分为三个区： Eden区、ServivorFrom、ServivorTo。</p><p>Eden区：Java新对象的出生地，当此区内存不够时即触发GC，对新生代区进行一次垃圾回收。</p><p>ServivorTo：保留一次GC过程中的幸存者</p><p>ServivorFrom：上一次GC的幸存者，作为本次GC的被扫描者。</p><p>本区GC一般采用复制算法。</p><p>2.何为老年代？</p><p>当新生代无法找到足够大连续空间给新创建的较大对象时，会在老年代触发GC，一般采用标记清除算法。当老年代也没有空间时，会抛出OOM异常。</p></blockquote><h2 id="新生代回收器"><a href="#新生代回收器" class="headerlink" title="新生代回收器"></a>新生代回收器</h2><p>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge。</p><h2 id="老年代回收器"><a href="#老年代回收器" class="headerlink" title="老年代回收器"></a>老年代回收器</h2><p>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</p><blockquote><p>新生代回收器和老年代回收器一般配合使用，共同完成JVM中GC。</p><p>还有一个驾驭一切的垃圾回收器，在新生代，老年代都能使用，即G1。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>垃圾回收机制回收JVM堆内存里的对象空间,不负责回收栈内存数据。</li><li>对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。</li><li>垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。</li><li>可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。</li><li>现在的JVM有多种垃圾回收实现算法，表现各异。</li><li>垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。</li><li>我们可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hashmap</title>
    <link href="/2020/11/26/Hashmap/"/>
    <url>/2020/11/26/Hashmap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是由数组和链表组合构成的数据结构，数组插入键值对，当遇到哈希值相等的节点时，即在该节点上形成链表。当新的节点插入链表时，java8之前是头插法，java8之后变为尾插法，主要防止哈希表扩容时，头插法易形成循环链表。</p><h1 id="为何JAVA8之后改为尾插法？"><a href="#为何JAVA8之后改为尾插法？" class="headerlink" title="为何JAVA8之后改为尾插法？"></a>为何JAVA8之后改为尾插法？</h1><p>首先来看看HashMap的扩容机制：</p><blockquote><p>数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize.</p><p>一般有两个因素：Capacity–HashMap当前长度       LoadFactor–负载因子，默认值0.75f</p><p>即假设当前的容量大小为100，当存进第76个元素的时候，判断发现需要对哈希表进行resize。</p></blockquote><p>具体扩容分为两步进行：</p><p>  <strong>扩容</strong>：创建一个新的空数组，长度是原数组的2倍</p><p>  <strong>rehash</strong>：遍历原数组，把所有节点重新Hash到新数组</p><blockquote><p>为何要重新hash节点插入？直接复制更快？</p><p>因长度扩容之后，数组长度改变，Hash的规则也会随之改变</p></blockquote><p>具体到为什么改为尾插法更好，使用头插法，容量为2的容器，某一节点上链表A-B-C在不同线程扩容插入A,B,C时，可能会形成B-A-B的回环，而使用尾插不会改变链表上的顺序，扩容时即不会出现链表成环问题。由此JAVA8不会出现像JAVA7在多线程操作哈希表时的死循环问题。</p><p>但这并不说明JAVA8可以任意把哈希表使用在多线程中，通过源码可知put/get方法均没有加同步锁，还是无法保证上一秒put的值，下一秒get还是原值，即线程安全还是无法保证。</p><blockquote><p>哈希表的默认初始化长度是16        为经验值</p></blockquote><h1 id="为何重写equals方法要重写hashCode方法？"><a href="#为何重写equals方法要重写hashCode方法？" class="headerlink" title="为何重写equals方法要重写hashCode方法？"></a>为何重写equals方法要重写hashCode方法？</h1><p>java中所有的对象都是继承于Object类，而Ojbect类中有两个比较两个对象是否相等的方法：equals和hashCode。</p><p>而哈希表找到数组同一节点上的链表时，使用equals比较链表上不同的值，也就是说我们一定要对hashCode进行重写，以保证<strong>相同的对象返回相同的hash值，不同的对象返回不同的hash值</strong>。</p><h1 id="HashMap为何是线程不安全的"><a href="#HashMap为何是线程不安全的" class="headerlink" title="HashMap为何是线程不安全的"></a>HashMap为何是线程不安全的</h1><h2 id="jdk1-7中HashMap"><a href="#jdk1-7中HashMap" class="headerlink" title="jdk1.7中HashMap"></a>jdk1.7中HashMap</h2><p>原因一：扩容造成死循环</p><p>在对哈希表进行扩容时，扩容函数将原数据转移到新表中，也会使用头插法，造成链表顺序翻转，多线程情况下这里是形成死循环的关键点。</p><p>原因二：扩容造成数据丢失</p><p>在扩容时，也可能造成数据丢失，数据指向自己，形成自环</p><h2 id="jdk1-8中的HashMap"><a href="#jdk1-8中的HashMap" class="headerlink" title="jdk1.8中的HashMap"></a>jdk1.8中的HashMap</h2><p>在jdk1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，因此不会出现环形链表的情况，但是在多线程的情况下仍然不安全。诸如不同线程的put相互覆盖的情况。</p><h1 id="如何处理HashMap在线程不安全的情况"><a href="#如何处理HashMap在线程不安全的情况" class="headerlink" title="如何处理HashMap在线程不安全的情况"></a>如何处理HashMap在线程不安全的情况</h1><p>一般使用<strong>HashTable</strong>或者<strong>CurrentHashMap</strong>。</p><blockquote><p>虽然Hashtable和HashMap相比是线程安全的，但其在对数据操作时都会上锁，存在效率问题。另外<strong>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null</strong>。</p></blockquote><h1 id="ConcurrentHashMap如何保证线程安全？"><a href="#ConcurrentHashMap如何保证线程安全？" class="headerlink" title="ConcurrentHashMap如何保证线程安全？"></a>ConcurrentHashMap如何保证线程安全？</h1><p>ConcurrentHashMap的存值put步骤如下：</p><ol><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p></li></ol><p>ConcurrentHashMap的取值get步骤如下：</p><ol><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ol><h1 id="何为CAS，何为自旋？"><a href="#何为CAS，何为自旋？" class="headerlink" title="何为CAS，何为自旋？"></a>何为CAS，何为自旋？</h1><p>CAS 是乐观锁的一种实现方式，为一种轻量级的锁，认为并发操作并不总会发生。</p><p>具体流程为：线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p><p>但其不能检测ABA问题，即A被某线程修改为B，再被某线程修改回A。乐观锁CAS无法检测。</p><h1 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h1><h1 id="synchronized锁升级策略"><a href="#synchronized锁升级策略" class="headerlink" title="synchronized锁升级策略"></a>synchronized锁升级策略</h1>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《九零》（外两首）</title>
    <link href="/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/"/>
    <url>/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>​                        <strong>《九零》</strong></p><p>哨响冬末三九天，心系楚地八方援。</p><p>才笑九零纨绔子，挑灯提剑奔在前。</p><p>欲使天下除病事，敢为家国争人先。</p><p>满腔抱负今犹在，我辈英才正少年。</p><hr><p>才备腊酒留家宴，满城闭户锁门帘。</p><p>岁末不知春尚早，风将吹落谁家檐？</p><p>白衣同往御风雪，万民共载世多贤。</p><p>但看春光明媚去，家人闲坐笑谈天</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--判断回文数</title>
    <link href="/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目：判断一个数是否是回文数，12321是，但负数肯定不是，简单来说，排除负数后，判断整数反转后是否等于自身即可</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">boolean</span> <span class="hljs-title">huiwen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;       <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;       <span class="hljs-keyword">int</span> copyx=x,reverse=<span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span>(copyx!=<span class="hljs-number">0</span>)&#123;           reverse=reverse*<span class="hljs-number">10</span>+copyx%<span class="hljs-number">10</span>;           copyx/=<span class="hljs-number">10</span>;       &#125;       <span class="hljs-keyword">return</span> x==reverse;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--整数反转</title>
    <link href="/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>题目：将整数按位反转，注意若反转后数溢出则返回0</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(;x!=<span class="hljs-number">0</span>;x/=<span class="hljs-number">10</span>)        res = res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;    <span class="hljs-keyword">return</span> res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE?<span class="hljs-number">0</span>;(<span class="hljs-keyword">int</span>) res;&#125;循环部分等价于    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;        res=res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;        x=x/<span class="hljs-number">10</span>;    &#125;</code></pre><p><strong>Integer.MAX_VALUE和Integer.MIN_VALUE分别是整数int的最大和最小值</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--罗马数字转换</title>
    <link href="/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>题目：将罗马数字字符串转换为数字，当小字符在大字符前的时候，结果为大数减小数，如IV=4,IV=9</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">romantoInt</span><span class="hljs-params">(String s)</span></span>&#123;    Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>);    map.put(<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>);    map.put(<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>);    map.put(<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>);    map.put(<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>);    map.put(<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>);    map.put(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>);    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span> sum = map.get(s.charAt(len-<span class="hljs-number">1</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;        <span class="hljs-keyword">if</span>(map.get(s.charAt(i))&lt;map.get(s.charAt(i+!)))&#123;            sum=sum-map.get(s.charAt(i));        &#125;<span class="hljs-keyword">else</span>        &#123;            sum=sum+map.get(s.charAt(i));        &#125;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--两数求和</title>
    <link href="/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <url>/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目：两数求和返回下标，例如[2,7,11,15],目标值target=9，结果返回[0,1]</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"> Public <span class="hljs-keyword">int</span> [] towsum(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)&#123; <span class="hljs-keyword">int</span> len = nums.length;​HashMap&lt;Integer,Integer&gt; map= <span class="hljs-keyword">new</span> HashMap&lt;&gt;();​<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;++i)&#123;​<span class="hljs-keyword">final</span> Integer value = map.get(nums[i]);​<span class="hljs-keyword">if</span>(value!=<span class="hljs-keyword">null</span>)&#123;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;value,i&#125;;​&#125;​map.put(target-nums[i],i);​&#125;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p><strong>使用哈希表，键存target-nums[i]差值，值存相对应下标，若遍历时已存在，则返回目标对应值和当前下标</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图神经网络综述</title>
    <link href="/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/"/>
    <url>/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="图神经网络综述"><a href="#图神经网络综述" class="headerlink" title="图神经网络综述"></a>图神经网络综述</h1><h2 id="GNN简介与起源"><a href="#GNN简介与起源" class="headerlink" title="GNN简介与起源"></a>GNN简介与起源</h2><h2 id="GNN与传统NN区别"><a href="#GNN与传统NN区别" class="headerlink" title="GNN与传统NN区别"></a>GNN与传统NN区别</h2><h2 id="GNN分类"><a href="#GNN分类" class="headerlink" title="GNN分类"></a>GNN分类</h2><h2 id="GNN模型概览"><a href="#GNN模型概览" class="headerlink" title="GNN模型概览"></a>GNN模型概览</h2><h3 id="Original-GNN"><a href="#Original-GNN" class="headerlink" title="Original GNN"></a>Original GNN</h3><h3 id="GNN-Variants"><a href="#GNN-Variants" class="headerlink" title="GNN Variants"></a>GNN Variants</h3><h3 id="GNN的General-Framework"><a href="#GNN的General-Framework" class="headerlink" title="GNN的General Framework"></a>GNN的General Framework</h3><h2 id="GNN应用"><a href="#GNN应用" class="headerlink" title="GNN应用"></a>GNN应用</h2><h3 id="结构化场景"><a href="#结构化场景" class="headerlink" title="结构化场景"></a>结构化场景</h3><h3 id="非结构化场景"><a href="#非结构化场景" class="headerlink" title="非结构化场景"></a>非结构化场景</h3><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>（以上部分按照[Graph Neural Networks: A Review of Methods and Applications]进行编排书写，后面按照其参考文献逐步抽取）</p><hr><hr><h2 id="GNN模型论文"><a href="#GNN模型论文" class="headerlink" title="GNN模型论文"></a>GNN模型论文</h2><blockquote><p>此部分按照[The Graph Neural Network Model]综述论文书写，对GNN模型有较为详细介绍</p></blockquote><h2 id="GCN模型论文"><a href="#GCN模型论文" class="headerlink" title="GCN模型论文"></a>GCN模型论文</h2><blockquote><p>此部分按照[Semi-Supervised Classification with Graph Convolutional Networks]文章介绍书写，另外还有一篇博客可学习<a href="http://xtf615.com/2019/02/24/gcn/">http://xtf615.com/2019/02/24/gcn/</a></p></blockquote><h3 id="GCN演变"><a href="#GCN演变" class="headerlink" title="GCN演变"></a>GCN演变</h3><h3 id="详细GCN论文模型"><a href="#详细GCN论文模型" class="headerlink" title="详细GCN论文模型"></a>详细GCN论文模型</h3><h2 id="DCNN模型论文"><a href="#DCNN模型论文" class="headerlink" title="DCNN模型论文"></a>DCNN模型论文</h2><blockquote><p>此部分按照[Diffusion-Convolutional Neural Networks]的模型发展进行描述</p></blockquote><h2 id="Tree-LSTM模型论文"><a href="#Tree-LSTM模型论文" class="headerlink" title="Tree-LSTM模型论文"></a>Tree-LSTM模型论文</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="关于不动点定理"><a href="#关于不动点定理" class="headerlink" title="关于不动点定理"></a>关于不动点定理</h3><h3 id="关于递归求导"><a href="#关于递归求导" class="headerlink" title="关于递归求导"></a>关于递归求导</h3><h3 id="关于切比雪夫多项式"><a href="#关于切比雪夫多项式" class="headerlink" title="关于切比雪夫多项式"></a>关于切比雪夫多项式</h3><h3 id="关于图Fourier变换"><a href="#关于图Fourier变换" class="headerlink" title="关于图Fourier变换"></a>关于图Fourier变换</h3><h3 id="关于RNN系列模型"><a href="#关于RNN系列模型" class="headerlink" title="关于RNN系列模型"></a>关于RNN系列模型</h3><h2 id="灵光"><a href="#灵光" class="headerlink" title="灵光"></a>灵光</h2>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
      <tag>GCN</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
