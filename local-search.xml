<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Pytorch-Geometric安装笔记</title>
    <link href="/2021/01/07/Pytorch-Geometric%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/01/07/Pytorch-Geometric%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h1><p>1.操作系统：win10</p><p>2.python版本：3.6.10</p><p>3.cuda版本：10.1</p><p>4.pytorch版本：1.6.0</p><h1 id="相关依赖包"><a href="#相关依赖包" class="headerlink" title="相关依赖包"></a>相关依赖包</h1><p>安装pytorch-geometric前，需要先安装四个前置依赖，选择离线安装，这样比较快。</p><blockquote><p>torch-scatter</p><p>torch-sparse</p><p>torch-cluster</p><p>torch-spline-conv</p></blockquote><p>在<a href="https://pytorch-geometric.com/whl/%E5%8F%AF%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AFtorch-1.6.0+cu101">https://pytorch-geometric.com/whl/可选择对应版本下载，我选择的是torch-1.6.0+cu101</a></p><p>得到四个包,放入文件夹，然后本地离线加载。</p><blockquote><p>torch_cluster-1.5.7-cp36-cp36m-win_amd64.whl</p><p>torch_scatter-2.0.5-cp36-cp36m-win_amd64.whl</p><p>torch_sparse-0.6.7-cp36-cp36m-win_amd64.whl</p><p>torch_spline_conv-1.2.0-cp36-cp36m-win_amd64.whl</p></blockquote><p>然后在载入四个前置依赖后，输入</p><p>pip install torch-geometric</p><p>没有报错，即安装完成。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图计算讲座心得</title>
    <link href="/2020/12/15/%E5%9B%BE%E8%AE%A1%E7%AE%97%E8%AE%B2%E5%BA%A7%E5%BF%83%E5%BE%97/"/>
    <url>/2020/12/15/%E5%9B%BE%E8%AE%A1%E7%AE%97%E8%AE%B2%E5%BA%A7%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="《-从离线图计算到图数据库和图流计算》"><a href="#《-从离线图计算到图数据库和图流计算》" class="headerlink" title="\《******从离线图计算到图数据库和图流计算》****"></a><strong><em>\</em>《*****</strong>*从离线图计算到图数据库和图流计算》****</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="\背景介绍**"></a><strong><em>\</em>背景介绍**</strong></h3><table><thead><tr><th>主题</th><th>从离线图计算到图数据库和图流计算</th><th>时间</th><th>2020年11月23日</th><th></th><th></th></tr></thead><tbody><tr><td>地点</td><td>Bilibili图谱学苑</td><td>主讲人</td><td>陈文光</td><td>主讲人单位</td><td>清华大学</td></tr></tbody></table><h3 id="讲座内容"><a href="#讲座内容" class="headerlink" title="\讲座内容**"></a><strong><em>\</em>讲座内容**</strong></h3><p>\1. 将图计算引入传统方法可能无法良好解决的现实问题中，如失联修复（公司丢失客户联系方式，通过相关社交媒体账号找回），恶意网络攻击(基于图计算的恶意网址检测），反信用卡团伙欺诈（通过图计算发现团伙欺诈之间的关联性，利用社区发现算法发现申请间的关联性等）。上述算法本身都不复杂，复杂在图的计算上，本讲座讲述了如何处理这些巨大的图。</p><p>\2. 随着Spark成为大数据处理的实际标准，但其在图的处理上是十分低效的，具体体现在计算时间和计算空间上的巨量空耗。为解决此问题，涌现了许多图计算系统，详细介绍了三个并行图计算系统：GridGraph（高效率单机外存图计算系统，处理规模：万亿边），Gemini(分布式内存图计算系统，处理规模：万亿边），shentu(极大规模分布式内存图计算系统，处理规模：数十万亿边）。并介绍了图计算模型的基本模型和原理，如以边为中心的图处理模型，GridGraph的起点终点二维划分，Streaming-apply模式的双滑动窗口，稠密-稀疏双模式的计算模型。</p><p>\3. 讲述了对图划分算法的改进，chunk划分保留了局部性，已经局部感知性的chunking，多层次分块划分和任务窃取对负载平衡进行全局调整。也通过搜狗全中文网页有12万亿条边的例子来描述大规模分布式处理的问题。</p><p>\4. 图数据库是目前发展的最快的数据库，产品化的图数据库TuGraph通过LDBC SNB测试程序进行测试的效果介绍。最后对是否可以合并图计算和图数据库形成一站式图系统的可能进行探讨。</p><h3 id="个人心得"><a href="#个人心得" class="headerlink" title="\个人心得**"></a><strong><em>\</em>个人心得**</strong></h3><p>通过本次讲座，我系统了解到了图计算和图数据库的的相关知识，加深了从离线图计算到图数据图流计算的理解，对大规模图数据的同化计算有了新的认识，合并图计算与图数据库形成一站式图系统可能是未来一段时间图数据领域发展的重点，数据时代，图数据也发挥着越来越多的作用，可能对于越来越多的现实问题有了新的解决方法，分析节点和链接之间的关系，超大规模图计算的落地也将使大数据时代的复杂数据问题得到应有的解决。</p><h2 id="《-大规模时序图上最短路径查询》"><a href="#《-大规模时序图上最短路径查询》" class="headerlink" title="\《******大规模时序图上最短路径查询》****"></a><strong><em>\</em>《*****</strong>*大规模时序图上最短路径查询》****</h2><h3 id="背景介绍-1"><a href="#背景介绍-1" class="headerlink" title="\背景介绍**"></a><strong><em>\</em>背景介绍**</strong></h3><table><thead><tr><th>主题</th><th>大规模时序图上最短路径查询</th><th>时间</th><th>2020年11月23日</th><th></th><th></th></tr></thead><tbody><tr><td>地点</td><td>Bilibili图谱学苑</td><td>主讲人</td><td>袁野</td><td>主讲人单位</td><td>北京理工大学计算机学院</td></tr></tbody></table><h3 id="讲座内容-1"><a href="#讲座内容-1" class="headerlink" title="\讲座内容**"></a><strong><em>\</em>讲座内容**</strong></h3><p>本次讲座详细介绍了两种时序图模型，并介绍提出了一个更加通用的模型，可以普适性的解决时序图上的最短路径查询问题。袁老师线详细介绍了大图数据背景时序图的应用背景和基本定义，大图数据的计算分类为离线分析和在线查询，梳理了现有的时序图模型，然后从图查询处理帆帆，时序图管理系统等方面介绍了当前大规模时序图最短路径查询的详细研究工作。之后，详细讲解了大规模时序图上带约束的最短路径查询方法研究进展，给出了基于树分解的大图计算模型和相关应用的设计方案。就大图数据跨域计算进行了面向跨越的高效大图计算框架GeoGraph的相关扩展。最后，通过金融风险防控的实例讲解了图务实体经济上大图数据处理的应用。</p><h3 id="个人心得-1"><a href="#个人心得-1" class="headerlink" title="\个人心得**"></a><strong><em>\</em>个人心得**</strong></h3><p>最短路径查询作为图论研究的核心问题之一，现实世界中很多问题都能转化为最短路径问题求解。随着网络规模的不断扩张，传统经典的最短路径查询方法已无法满足大规模图的查询需求，本次讲座中，袁野老师通过对两种时序图模型的介绍，接着提出了目前来说更加通用的模型，在涉及大规模时序图上最短路径查询应用时，传统场景中的数据预处理都会被用作来提高查询效率的重要手段。袁老师的大规模图改进于大规模图中近似最短路径查询，又能适用于更广泛的时序图上，作为总结，不仅能为后来研究此方向的人给出新的方向和思路，也能对图论中关于大规模图最短路径问题的快速求解做出新的推进。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCN节点分类实验（一）</title>
    <link href="/2020/12/13/GCN%E8%8A%82%E7%82%B9%E5%88%86%E7%B1%BB%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/12/13/GCN%E8%8A%82%E7%82%B9%E5%88%86%E7%B1%BB%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="GCN实验"><a href="#GCN实验" class="headerlink" title="GCN实验"></a>GCN实验</h1><h2 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h2><p>实验数据集选用Cora数据集，该数据集由2708篇论文以及代表它们之间引用关系构成的5429条边组成。</p><p>数据集里论文按照主题大致分为七类：神经网络，强化学习，规划学习，概率方法，遗传算法，理论研究，案例相关。且每篇论文特征通过词袋模型得到，维度为1433，每一维表示一个词，1表示该词在文中出现过，0表示未出现过。</p><blockquote><p>文本向量化表示–词袋模型</p><p>词袋模型使用一组词语序列来表示一段文本，这一组词语序列就是词袋模型，也可以叫词汇表。词汇表中每个词语之间的顺序是任意的，但是一旦词汇表确定后词语之间的前后顺序就不能变化了。由于词语之间的顺序任意，所以词袋模型忽略了文本的语法和语序要素。词袋模的One-Hot表示法、TF表示法、TF-IDF表示法的数值计算规则都没有考虑词语之间的共现关系。</p><p>TF表示法：词语序列中出现的词语其数值为词语在所在文本中的频次，词语序列中未出现的词语其数值为0。</p><p>TF-IDF表示法：词语序列中出现的词语其数值为词语在所在文本中的频次乘以词语的逆文档频率，词语序列中未出现的词语其数值为0。</p><p>逆文档频率：所有文档中出现频次的倒数</p></blockquote><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>主要将数据下载后，规范化数据，最后将数据规范化为以下几个部分：</p><ol><li>X：节点特征，即维度为2708*1433。</li><li>Y:节点对应标签，即上述7个类别。</li><li>A：邻接矩阵，维度为2708*2708。</li></ol><h2 id="可视化结果"><a href="#可视化结果" class="headerlink" title="可视化结果"></a>可视化结果</h2><p><img src="/img/keshihua.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GCN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记(二)</title>
    <link href="/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <url>/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote><p>传统的关系型数据库如Mysql等已不能适用所有场景，如秒杀的库存扣减，APP的首页访问流量高峰等，这些情况都很容易把数据库打崩，所有Redis作为缓存中间件横空出世。</p></blockquote><h2 id="缓存穿透与布隆过滤器"><a href="#缓存穿透与布隆过滤器" class="headerlink" title="缓存穿透与布隆过滤器"></a>缓存穿透与布隆过滤器</h2><blockquote><p>判断不存在的数据没有必要让Mysql再次查询，Redis利用布隆过滤器挡下那些明显不会有结果的查询请求。</p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器可以用于检索一个元素是否再一个集合中，其优点是空间效率和查询时间都远超一般算法，但有一定的误识别率和删除困难。</p><h3 id="布隆过滤器基本原理"><a href="#布隆过滤器基本原理" class="headerlink" title="布隆过滤器基本原理"></a>布隆过滤器基本原理</h3><p>布隆过滤器本质为bitmap位数组的扩展。例如有0-31范围的25个不重复数字，如何判断18在不在其中?</p><ol><li>第一种做法是建立数字数组，使用int8单字节数组，需要8*32=256位，即32字节的空间。</li><li>第二种做法使用一个int32的变量，该变量4个字节，可用bit0表示数字0，bit1表示数字1，。。。依次类推。即知我们使用4字节空间就完成了方法一32字节的工作。</li></ol><h4 id="布隆过滤器两大组件"><a href="#布隆过滤器两大组件" class="headerlink" title="布隆过滤器两大组件"></a>布隆过滤器两大组件</h4><blockquote><ol><li>一定大小的BitAarry位阵列（具体大小与存储规模相关）</li><li>N个可用的哈希函数（N的个数与存储规模，容忍误判率等有关）降低哈希冲突，尽量选用优秀的哈希函数。</li></ol></blockquote><p>两组件分工为，位阵列存储对应位的值是0/1的二进制向量，哈希函数将原始输入经过数字运算转换为一个数字值。</p><h4 id="布隆过滤器与哈希冲突"><a href="#布隆过滤器与哈希冲突" class="headerlink" title="布隆过滤器与哈希冲突"></a>布隆过滤器与哈希冲突</h4><p>哈希冲突虽然概率很低，但是在大规模数据场景下还是会出现，可尽量选用表现更优秀的哈希函数，或者多个哈希共同使用。</p><h4 id="布隆过滤器的具体使用"><a href="#布隆过滤器的具体使用" class="headerlink" title="布隆过滤器的具体使用"></a>布隆过滤器的具体使用</h4><p>假设三个哈希函数h1，h2，h3，有三个输入a,b,c已存在，分别通过三个哈希函数计算出对应整数后，对bitarray长度取模后将对应位置置1.</p><p>当布隆过滤器检索时，使用相同哈希函数进行计算，只要对应位置中，任何一个位置有0，则被检元素一定不存在，若对应位置都是1，则被检元素可能存在。</p><p>网上找图，如下所示：</p><p><img src="/img/bulong.png"></p><blockquote><p><strong>有0一定不存在，全1不一定存在</strong></p></blockquote><blockquote><p>所以布隆过滤器存在一定的误判，主要因素包括：</p><ol><li>哈希函数本身的冲突率</li><li>bitarray位数组的大小</li></ol></blockquote><blockquote><p>因为对位置重复赋值，所以一般不能从布隆过滤器删除元素</p></blockquote><h2 id="布隆过滤器的典型应用"><a href="#布隆过滤器的典型应用" class="headerlink" title="布隆过滤器的典型应用"></a>布隆过滤器的典型应用</h2><ol><li>缓存穿透过滤</li><li>检查单词拼写正确性</li><li>垃圾邮件过滤:如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</li><li>检查海量名单嫌疑人</li><li>搜索爬虫URL去重:爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记(一)</title>
    <link href="/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis是一个完全开源的高性能key-value数据库.</p><h2 id="Redis的数据结构与应用场景"><a href="#Redis的数据结构与应用场景" class="headerlink" title="Redis的数据结构与应用场景"></a>Redis的数据结构与应用场景</h2><blockquote><p>使用场景:缓存,共享session,消息队列系统,分布式锁</p></blockquote><blockquote><p>单线程Redis快的原因?</p><ol><li>纯内存操作</li><li>单线程操作,避免了频繁上下文切换</li><li>合理高效的数据结构</li><li>采用非阻塞I/O多路复用机制</li></ol></blockquote><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><p>字符串是Redis最基础的数据结构.其中键都是字符串类型,剩下几种数据结构都是在字符串类型基础上构建的.常用在缓存,计数,共享session,限速等方面.</p><h3 id="Hash哈希"><a href="#Hash哈希" class="headerlink" title="Hash哈希"></a>Hash哈希</h3><p>Redis中,哈希类型是指键值本身又是一个键值对结构的数据.可用来存放用户信息,实现诸如购物车等功能.</p><h3 id="List列表-双向链表"><a href="#List列表-双向链表" class="headerlink" title="List列表(双向链表)"></a>List列表(双向链表)</h3><p>列表类型可用来存储多个有序的字符串,可做简单的消息队列功能.</p><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>集合类型可用来保存多个的字符串元素,与列表不同的是,集合中不允许重复元素且元素无序,不能通过索引下标获取元素.可通过Set的交集,并集,差集等来计算重合元素.</p><h3 id="Sorted-Set有序集合"><a href="#Sorted-Set有序集合" class="headerlink" title="Sorted Set有序集合"></a>Sorted Set有序集合</h3><p>相对Set多了一个权重参数Score,集合中元素能按Score进行排列.常用来做排行榜,取Top N.</p><h2 id="Redis的数据过期策略"><a href="#Redis的数据过期策略" class="headerlink" title="Redis的数据过期策略"></a>Redis的数据过期策略</h2><blockquote><p>Redis中数据过期策略采用定期删除与惰性删除策略</p></blockquote><h3 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h3><p>Redis会启动一个定时器定时监视所有key，判断key的时效性，若过期即删除key。此方法能保证过期的key最终都能被删除。但本方法每次都要遍历内存中所有数据，非常消耗CPU资源。并且当Key过期后，定时器还未被唤起，这一段时间内的key仍然可用。</p><h3 id="惰性删除策略"><a href="#惰性删除策略" class="headerlink" title="惰性删除策略"></a>惰性删除策略</h3><p>在获取到key时，判断key是否过期，若过期则删除。本方法缺点是：若某个key一直未被使用，则其将会一直在内存中，占用空间。</p><h3 id="两者结合策略"><a href="#两者结合策略" class="headerlink" title="两者结合策略"></a>两者结合策略</h3><p>定时删除策略不再扫描全部key。而是随机抽取部分key进行检查，从而降低对CPU的损耗。惰性删除策略弥补了可能未被检查到的key。若还是存在过期的key，既没有被定时器抽取，也没有被使用，则当内存不够时，使用内存淘汰机制进行淘汰。</p><blockquote><p>移除最近最少使用的key/随机移除某个key </p><p>LRU（Least Recently Used) 最近最少使用</p></blockquote><h4 id="如何实现LRU"><a href="#如何实现LRU" class="headerlink" title="如何实现LRU"></a>如何实现LRU</h4><p>一般使用HashMap和双向链表实现LRU。使用HashMap存储key，而value指向双向链表实现的LRU的Node节点，如图：</p><p><img src="/img/LRU.png"></p><p>h表头，t表尾，预先设置LRU的容量。若存储满了，则O（1）时间淘汰掉双向链表的表尾。每次访问数据，都可通过O（1）效率把新节点增加到队头或把已存在点移动到队头。</p><h4 id="Redis的LRU具体实现"><a href="#Redis的LRU具体实现" class="headerlink" title="Redis的LRU具体实现"></a>Redis的LRU具体实现</h4><p>Redis每次按key获取一个值时，都会更新value中的LRU字段为当前秒级别的时间戳。</p><p>第一版LRU为，随机从dict中取出五个key，淘汰一个LRU最小的。</p><p>在3.0时，改进一版算法，首先第一批随机挑选的key会放进一个pool中（默认大小16），pool中的key是按LRU字段大小顺序排列。接下来每次随机挑选的key的LRU必须小于pool的最小LRU才会继续放入，直至pool放满。放满后，若有新的key需要放入，则将pool中LRU最大的key取出。淘汰的时候，直接从pool中选取LRU最小的值进行淘汰即可。</p><h2 id="Redis如何发现热点key"><a href="#Redis如何发现热点key" class="headerlink" title="Redis如何发现热点key"></a>Redis如何发现热点key</h2><p>Redis主要有五种发现热点key的方法：</p><ol><li>凭借经验预估：提前知道某个活动的开启，将该key作为热点key。</li><li>服务端收集：在操作redis前，加入计数代码进行数据统计。</li><li>抓包评估：Redis使用TCP协议与客户端通信，通信协议采用RESP，即自己写程序监听端口能进行拦截包分析。</li><li>在proxy层，对每个redis请求进行收集上报。（proxy–代理服务器）</li><li>Redis自带命令查询：Redis4.0.4版本后，使用命令redis-cli-hotkeys能找出热点key</li></ol><h3 id="Redis缓存雪崩问题的解决"><a href="#Redis缓存雪崩问题的解决" class="headerlink" title="Redis缓存雪崩问题的解决"></a>Redis缓存雪崩问题的解决</h3><ol><li>使用Redis高可用框架：使用 Redis 集群来保证 Redis 服务不会挂掉。</li><li>缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效。</li><li>限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务。</li></ol><h3 id="Redis缓存穿透问题的解决（待详细展开）"><a href="#Redis缓存穿透问题的解决（待详细展开）" class="headerlink" title="Redis缓存穿透问题的解决（待详细展开）"></a>Redis缓存穿透问题的解决（待详细展开）</h3><ol><li>在接口做校验。</li><li>缓存击穿加锁/设置不过期</li><li>布隆过滤器拦截</li></ol><h2 id="Redis的几种集群模式"><a href="#Redis的几种集群模式" class="headerlink" title="Redis的几种集群模式"></a>Redis的几种集群模式</h2><blockquote><ol><li>主从复制</li><li>哨兵模式</li><li>cluster模式</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记(一)</title>
    <link href="/2020/12/01/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2020/12/01/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="事务的基本要素"><a href="#事务的基本要素" class="headerlink" title="事务的基本要素"></a>事务的基本要素</h2><blockquote><p>原子性,一致性,隔离性,持久性——-ACID</p></blockquote><ol><li>原子性(atomicity),即事务是一个原子操作单元,对数据的修改,要么全部执行,要么全部不执行</li><li>一致性(consistency),即事务开始与结束前,数据库的完整性约束未被破坏</li><li>隔离性(isolation),即同一时间,只允许一个事务请求同一数据,不同事务间没有任何干扰</li><li>持久性(durability),即事务完成后,事务对数据库的所有更新将被保存到数据库,不能回滚</li></ol><h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><blockquote><p>脏读,不可重复读,幻读</p></blockquote><ol><li><p>脏读,即事务A读取了事务B更新的数据,然后B进行了回滚,那A读取到的数据是脏数据</p></li><li><p>不可重复读,即事务A多次读取同一数据,事务B在A多次读取过程中,对数据做了更新并提交,导致A多次读取的内容不一致</p></li><li><p>幻读,即事务A读取了事务B已提交的新增数据.也是重复读取不一致.</p><blockquote><p>幻读是新增数据,不可重复读是更改数据.</p></blockquote></li></ol><h2 id="Mysql事务的隔离级别"><a href="#Mysql事务的隔离级别" class="headerlink" title="Mysql事务的隔离级别"></a>Mysql事务的隔离级别</h2><blockquote><p>读未提交:可以读到未提交的内容,可能产生脏读,不可重复读,幻读</p><p>不可重复读(读提交):只能读到已提交的内容</p><p>可重复读:查询事务启动时,不允许进行更改操作了,为Mysql的默认隔离级别</p><p>串行化: 数据库最高隔离级别,事务必须一个一个排队执行,按串行化顺序</p><ol><li>为何出现脏读?   select操作没有规矩</li><li>为何出现不可重复读?  update操作没有规矩</li><li>为何出现幻读?   insert和delete没有规矩</li></ol></blockquote><table><thead><tr><th align="center">事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td>是</td><td>是</td><td>是</td></tr><tr><td align="center">不可重复读(读提交)</td><td>否</td><td>是</td><td>是</td></tr><tr><td align="center">可重复读</td><td>否</td><td>否</td><td>是</td></tr><tr><td align="center">串行化</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h2 id="sql语句执行顺序"><a href="#sql语句执行顺序" class="headerlink" title="sql语句执行顺序"></a>sql语句执行顺序</h2><p>from</p><p>where</p><p>group by</p><p>having</p><p>select</p><p>order by</p><h2 id="Mysql的存储引擎"><a href="#Mysql的存储引擎" class="headerlink" title="Mysql的存储引擎"></a>Mysql的存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>是基于聚簇索引建立的,其支持事务,外键,并且通过MVCC来支持高并发以及索引数据一体存储.Mysql5.5.8版本后成为默认存储引擎</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>为5.1版本前的默认引擎,支持全文检索,压缩,空间函数,但不支持事务和行级锁,一般用在大量查询少量插入的场景,且不支持外键,其索引和数据是分开存储的</p><h2 id="Mysql的逻辑结构"><a href="#Mysql的逻辑结构" class="headerlink" title="Mysql的逻辑结构"></a>Mysql的逻辑结构</h2><blockquote><p>最上层服务类似CS结构,进行连接处理,授权处理</p></blockquote><blockquote><p>第二层为Mysql服务层,SQL语句的解析分析优化,存储过程触发器视图等都在本层实现</p></blockquote><blockquote><p>最下层为存储引擎的实现,类似Java接口实现,在调用时会屏蔽不同引擎实现间的差异</p></blockquote><h2 id="Mysql的日志系统"><a href="#Mysql的日志系统" class="headerlink" title="Mysql的日志系统"></a>Mysql的日志系统</h2><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>即回滚日志文件,主要用于事务执行失败,进行回滚,在MVCC中对数据历史版本查看.由引擎层的InnoDB引擎实现,为逻辑日志,记录数据被修改前的值.保证了事务的一致性</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>即重做日志文件,记录数据修改后的值,用于持久化到磁盘中,由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息(诸如某个数据页上的内容发生改动).当某条数据需要更新,InnoDB会先将数据更新,然后记录redo log在内存中,找个时间将redo log操作执行到磁盘文件上.不管提交是否成功,都会记录,若进行回滚操作,也会记录回滚.保证了事务的持久性.</p><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h3><p>是Mysql中基于乐观锁理论实现隔离级别的方式,用于读提交和可重复读隔离级别的实现.在Mysql中,会在表中每条数据后添加两个字段:<strong>最近修改改行数据的事务ID</strong>和<strong>指向改行回滚段(undolog)的指针</strong>.实际上为保存了数据在某个时间节点的快照.</p><h3 id="binlog与redo-log区别"><a href="#binlog与redo-log区别" class="headerlink" title="binlog与redo log区别"></a>binlog与redo log区别</h3><ol><li>redo log是在InnoDB存储引擎层产生,而binlog是MySQL数据库的上层服务层产生</li><li>两种日志记录内容形式差异.binlog是逻辑日志,记录对应的sql语句和事务;而redo log是物理日志,记录的是关于每个页的更改的物理情况</li><li>两种日志的记录写入磁盘的时间点不同,binlog只在事务提交完成后进行一次写入.而redo log在事务进行中不断被写入.</li><li>binlog不是循环使用,在写满或重启后,才会生成新的binlog文件,redo log是循环使用</li><li>两者都能进行数据恢复.</li></ol><h2 id="Mysql如何保证一致性和持久性"><a href="#Mysql如何保证一致性和持久性" class="headerlink" title="Mysql如何保证一致性和持久性"></a>Mysql如何保证一致性和持久性</h2><p>为保证ACID中的一致性和持久性,使用了先写日志再写磁盘的操作,即WAL(write-Ahead logging)</p><p>当数据库断电再重新启动时,mysql可以通过redo log还原数据;即只要在每次事务刷新时,同步刷新redo log即可,不用同步刷新磁盘数据文件.</p><h2 id="Mysql锁的类型"><a href="#Mysql锁的类型" class="headerlink" title="Mysql锁的类型"></a>Mysql锁的类型</h2><p>mysql的锁分为共享锁和排他锁,即读锁和写锁.</p><p>读锁为共享的,可通过lock in share mode实现,只能读不能写</p><p>写锁为排他的,会阻塞其他的写锁和读锁.</p><p>另外,通过颗粒度来分,又分为表锁和行锁两种.</p><p>其中表锁会锁定整张表并阻塞其他用户对该表所有的读写操作.阻塞诸如alter修改表结构等的操作</p><p>行锁又可分为乐观锁和悲观锁两种,悲观锁通过for update实现,乐观锁通过版本号实现.</p><h3 id="InnoDB的行锁模式"><a href="#InnoDB的行锁模式" class="headerlink" title="InnoDB的行锁模式"></a>InnoDB的行锁模式</h3><ol><li>共享锁(S):用法即lock in share mode,允许一个事务去读一行,阻止其他数据获得相同数据的排他锁.意思是,若事务1对数据对象A加了S锁,事务1可以读A但不能修改A,其他事务对A也只能加S锁,而不能加X锁,直至事务1释放A上的S锁</li><li>排他锁(X):用法for update,允许获取排他锁事务更新数据,阻止其他事务对相同数据加锁.若事务1对数据A进行加锁,其他事务不能再对A加任何锁.</li></ol><blockquote><p>在没有索引的情况下,InnoDB只能使用表锁</p></blockquote><h2 id="Mysql的索引"><a href="#Mysql的索引" class="headerlink" title="Mysql的索引"></a>Mysql的索引</h2><blockquote><p>索引按照数据结构来讲,主要包含B+树和Hash索引</p></blockquote><h3 id="为什么选择B-树为索引结构"><a href="#为什么选择B-树为索引结构" class="headerlink" title="为什么选择B+树为索引结构"></a>为什么选择B+树为索引结构</h3><ul><li>Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</li><li>二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。</li><li>平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。</li><li>红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。</li><li>B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效</li></ul><h3 id="B-树的叶子节点都可以存哪些东西"><a href="#B-树的叶子节点都可以存哪些东西" class="headerlink" title="B+树的叶子节点都可以存哪些东西"></a>B+树的叶子节点都可以存哪些东西</h3><p>可能存储的是整行数据，也有可能是主键的值。B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引</p>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--括号匹配</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><blockquote><p>可以考虑使用数组来模拟栈操作，另外让top=1，省去判断栈空，和数组越界的问题</p><p>在遇到）时，判断栈顶是否是（，以此类推</p></blockquote><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">boolean</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(String s)</span></span>&#123;    <span class="hljs-keyword">char</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[s.length()+<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> top=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:s.toCharArray())&#123;        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;(&#x27;</span>||c==<span class="hljs-string">&#x27;[&#x27;</span>||c==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;            stack[top++]=c;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;）&#x27;</span>&amp;&amp;stack[--top]!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;stack[--top]!=<span class="hljs-string">&#x27;[&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;&#123;&#x27;</span>&amp;&amp;stack[--top]!=<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> top==<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--移除有序数组重复元素</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="移除有序数组重复元素"><a href="#移除有序数组重复元素" class="headerlink" title="移除有序数组重复元素"></a>移除有序数组重复元素</h1><blockquote><p>题目:移除有序数组重复元素，返回剩余元素个数。例如[1,1,2,2,3],返回3</p><p>使用一个指针指向头部，进行赋值</p></blockquote><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span>(len&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> len;    <span class="hljs-keyword">int</span> tail = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;len;++i)&#123;        <span class="hljs-keyword">if</span>(nums[i-<span class="hljs-number">1</span>]!=nums[i])&#123;            nums[tail++]=nums[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> tail;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--寻找子串</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找子串"><a href="#寻找子串" class="headerlink" title="寻找子串"></a>寻找子串</h1><blockquote><p>题目:在一字符串中寻找子串，返回子串首字母索引，若未找到返回-1。</p><p>即找到在s1中遍历完s2的位置可求解</p><p>例如，s1=hello，s2=ll，则返回2</p></blockquote><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">strstr</span><span class="hljs-params">(String s1,String s2)</span></span>&#123;    <span class="hljs-keyword">int</span> l1= s1.length(),l2=s2.length();    <span class="hljs-keyword">if</span>(l1&lt;l2) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;;i++)&#123;        <span class="hljs-keyword">if</span>(i+l2&gt;l1) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;     <span class="hljs-comment">//剩余长度不足以遍历完</span>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;;j++)&#123;            <span class="hljs-keyword">if</span>(j=l2) <span class="hljs-keyword">return</span> i;   <span class="hljs-comment">//遍历完s2情况</span>            <span class="hljs-keyword">if</span>(s1.charAt(i+j)!=s2.charAt(j))                <span class="hljs-keyword">break</span>;        &#125;    &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--寻找插入位置</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找插入位置"><a href="#寻找插入位置" class="headerlink" title="寻找插入位置"></a>寻找插入位置</h1><blockquote><p>题目:从一个无重复元素已排序数组找到插入位置索引。例如，[1,3,5,6],插入数字2，即返回1；[1，3，5，6] 插入数字5，即返回2；</p></blockquote><p>可通过二分查找找到第一个大于等于target元素位置</p><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)</span></span>&#123;    <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>,mid = (right+left)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;        <span class="hljs-keyword">if</span>(target&lt;=nums[mid])&#123;            right=mid-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            left = mid+<span class="hljs-number">1</span>;        &#125;        mid = (right+left)&gt;&gt;<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--跳水板拼凑</title>
    <link href="/2020/11/29/leetcode-%E8%B7%B3%E6%B0%B4%E6%9D%BF/"/>
    <url>/2020/11/29/leetcode-%E8%B7%B3%E6%B0%B4%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="跳水板拼凑"><a href="#跳水板拼凑" class="headerlink" title="跳水板拼凑"></a>跳水板拼凑</h1><p>题目:有两块板子，长度为x和y，假设有k块，输出所有可能的拼凑长度，例如x=1,y=2,k=3，输出[3,4,5,6]</p><p>本题可看成首项为k<em>x，末项为k</em>y，公差为y-x的等差数列，每用长的替换短的，都是加一次公差，项数为k+1.</p><p>代码如下:</p><pre><code class="hljs java">Public <span class="hljs-keyword">int</span> [] result(<span class="hljs-keyword">int</span> shorter,<span class="hljs-keyword">int</span> longer,<span class="hljs-keyword">int</span> k)&#123;    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">if</span>(shorter==longer)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;shorter*k&#125;;    &#125;    <span class="hljs-keyword">int</span>[] ans=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k+<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> sx = k*shorter;    <span class="hljs-keyword">int</span> delta = longer-shorter;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;=k;i++)&#123;        ans[i]=sx+i*delta;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树总结</title>
    <link href="/2020/11/28/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/2020/11/28/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote><p>什么是二叉查找树（BST）？</p><ol><li><p><strong>左</strong>子树上所有结点的值均<strong>小于或等于</strong>它的根结点的值</p></li><li><p><strong>右</strong>子树上所有结点的值均<strong>大于或等于</strong>它的根结点的值。</p></li><li><p>左、右子树也分别为二叉排序树。</p><p>基于二分查找建树。但存在插入之后节点不平衡情况，由此引入红黑树。</p></li></ol></blockquote><p>红黑树是一种自平衡的二叉查找树，其具有如下特性：</p><ol><li>节点是红色或黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点（NIL节点）。</li><li>每个红色节点的两个子节点都是黑色。即从叶子到根不可能有两个连续的红色节点</li><li>从任意节点到其每个叶子的所有路径都包含相同数目黑色节点。</li></ol><p>典型红黑树如图：</p><p><img src="/img/hongheishu.png"> </p><p>由上述构建规则限制，保证了红黑树从根到叶子的最长路径不会超过最短路径的2倍。</p><h2 id="红黑树的调整"><a href="#红黑树的调整" class="headerlink" title="红黑树的调整"></a>红黑树的调整</h2><p>当插入和删除节点时，红黑树规则会被打破，此时要对其进行调整，以满足条件。调整有两种方法：<strong>变色</strong>和<strong>旋转</strong>，而旋转又分为左旋转和右旋转。</p><h3 id="红黑树的左旋和右旋"><a href="#红黑树的左旋和右旋" class="headerlink" title="红黑树的左旋和右旋"></a>红黑树的左旋和右旋</h3><p>左旋即<strong>逆时针</strong>旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子，如图：</p><p><img src="/img/hongheishuzuoxuan.png"></p><p>右旋即<strong>顺时针</strong>旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。如图：</p><p><img src="/img/hongheishuyouxuan.png"></p><p> 实际使用中，变色和旋转视情况混合使用。</p><h3 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h3><p>在JDK的集合类TreeMap和TreeSet底层都是红黑树实现。在Java8中，HashMap也用到了红黑树.</p>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对偶</title>
    <link href="/2020/11/27/%E5%AF%B9%E5%81%B6/"/>
    <url>/2020/11/27/%E5%AF%B9%E5%81%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="不定期更新的闪耀时刻"><a href="#不定期更新的闪耀时刻" class="headerlink" title="不定期更新的闪耀时刻"></a>不定期更新的闪耀时刻</h1><p>南风过境/梦至西洲</p><p>三山时春/四水常在</p><p>扁舟子/明月楼</p><p>轻云蔽月/流风回雪</p><p>花酿酒/水煎茶</p><p>家人闲坐，灯火可亲。</p><p>塞北风沙酒，江南烟雨桥。</p><p>玉在山而草木润，渊生珠而崖不枯。</p><p>冬月新落雪，徐步纳子岁。</p><p>投入亡地然后存，陷入绝处而后生。</p><p>为众人抱薪者，不可使其扼于风雪。</p><p>欢声笑语别枝后，漫天星子正少年。</p><p>大梦谁先觉，平生我自知。</p><p>青天有月来几时，我今停杯一问之。</p><p>长安陌上无穷树，唯有垂杨管别离。</p><p>敬这大争之世，敬这小酌之时。</p><p>虹贯荆卿之心，碧化苌弘之血。</p><p>时日低矮而天下羊白</p><p>水清鱼读月，花静鸟谈天。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java垃圾回收机制</title>
    <link href="/2020/11/27/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/11/27/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>GC虽然已经自动帮我们完成清理，但了解一下java垃圾回收机制，还是对我们性能调优，问题排查等有很大帮助。本文为博主阅读网上资料后做的相关整理。</p><h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><p>1.虚拟机栈：每个方法被执行的同时会创建<strong>栈桢</strong> ，要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机都很明确，此处<strong>不需要进行 GC</strong>。</p><p>2.本地方法栈：虚拟机栈为虚拟机执行 Java 方法时服务，本地方法栈为虚拟机执行本地方法时服务，此处也<strong>不需要进行 GC</strong>。</p><p>3.程序计数器：线程独有。可以看作是当前线程执行的字节码的行号指示器。Java虚拟机的多线程是通过线程轮流切换并分配处理器的时间来完成的。在任何一个时刻，一个处理器只会执行一个线程，如果这个线程被分配的时间片执行完了（线程被挂起），处理器会切换到另外一个线程执行，程序计数器即记录唤醒线程时上次执行到的位置。另外<strong>程序计数器是唯一一个 Java 虚拟机规范中没有规定任何 OOM 情况的区域</strong>。此处也<strong>不需要进行 GC</strong>。</p><p>4.本地内存：即堆外内存，包含元空间和直接内存，JAVA8之后此区域也<strong>不需要进行 GC</strong>。</p><p>5.堆：对象实例和数组都是在堆上分配，GC主要针对这些数据进行回收，<strong>堆是java垃圾回收处理的主要区域</strong>。</p><h1 id="系统垃圾识别"><a href="#系统垃圾识别" class="headerlink" title="系统垃圾识别"></a>系统垃圾识别</h1><p>GC如何判断堆中对象实例等是不是垃圾？</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>为对象添加引用次数属性，被引用一次，即加一。未被引用即为0，代表可被回收。</p><p>但此类无法解决循环引用的问题，在互相被引用的对象要求释放时，因为引用次数不为零，造成无法回收。因此此方法用得较少。</p><h2 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h2><p>利用一个GC Root的对象为起点出发，逐步指向下一个可达的节点，直至所有节点遍历完毕，不在生成的这个引用链上的对象，即被判断为垃圾，会被GC回收。</p><p>另外，不是a, b 对象可回收，就一定会被回收。对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收。且<strong>finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收。</strong></p><blockquote><p>GC Root是什么？哪些对象可作为GC Root？</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul></blockquote><h1 id="垃圾回收主要方法"><a href="#垃圾回收主要方法" class="headerlink" title="垃圾回收主要方法"></a>垃圾回收主要方法</h1><p>通过可达性算法识别了哪些数据是垃圾，如何对垃圾进行回收？主要有以下三种方法。</p><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><ol><li><p>根据可达性算法标记出所有的可回收对象</p></li><li><p>对可回收对象进行回收</p></li></ol><p>此种算法回收之后会造成很多零碎的小内存，不能满足连续内存的需要</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ol><li><p>将堆分为两块区域,A,B,区域A分配对象，B不分配对象</p></li><li><p>对A使用标记法把存活的对象都标记出来，并将它们复制到区域B</p></li><li><p>把A中对象全部清理释放空间</p></li></ol><p>此方法解决了内存碎片的问题，缺点是堆空间大小利用率大大降低，复制也有资源浪费。</p><h2 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h2><ol><li><p>根据可达性算法标记出所有的可回收对象</p></li><li><p>对标记对象进行整理，将所有存活对象都往一端移动，紧密排列</p></li><li><p>清除掉另一端所有非存活对象</p></li></ol><h1 id="当前垃圾回收器对比"><a href="#当前垃圾回收器对比" class="headerlink" title="当前垃圾回收器对比"></a>当前垃圾回收器对比</h1><p>说完了垃圾回收的方法论，到了垃圾回收器就是内存回收的具体实现了，当前垃圾回收器按使用时期分为如下几类：</p><blockquote><p>JVM中的堆，一般分为三部分：新生代，老年代，永久代（JAVA8永久代移除，被元空间取代）</p><p>1.何为新生代？</p><p>主要用来存放新生对象，一般占堆空间的三分之一空间，会频繁创建对象，频繁触发GC进行垃圾回收。</p><p>新生代又分为三个区： Eden区、ServivorFrom、ServivorTo。</p><p>Eden区：Java新对象的出生地，当此区内存不够时即触发GC，对新生代区进行一次垃圾回收。</p><p>ServivorTo：保留一次GC过程中的幸存者</p><p>ServivorFrom：上一次GC的幸存者，作为本次GC的被扫描者。</p><p>本区GC一般采用复制算法。</p><p>2.何为老年代？</p><p>当新生代无法找到足够大连续空间给新创建的较大对象时，会在老年代触发GC，一般采用标记清除算法。当老年代也没有空间时，会抛出OOM异常。</p></blockquote><h2 id="新生代回收器"><a href="#新生代回收器" class="headerlink" title="新生代回收器"></a>新生代回收器</h2><p>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge。</p><h2 id="老年代回收器"><a href="#老年代回收器" class="headerlink" title="老年代回收器"></a>老年代回收器</h2><p>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</p><blockquote><p>新生代回收器和老年代回收器一般配合使用，共同完成JVM中GC。</p><p>还有一个驾驭一切的垃圾回收器，在新生代，老年代都能使用，即G1。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>垃圾回收机制回收JVM堆内存里的对象空间,不负责回收栈内存数据。</li><li>对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。</li><li>垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。</li><li>可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。</li><li>现在的JVM有多种垃圾回收实现算法，表现各异。</li><li>垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。</li><li>我们可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2020/11/26/Hashmap/"/>
    <url>/2020/11/26/Hashmap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是由数组和链表组合构成的数据结构，数组插入键值对，当遇到哈希值相等的节点时，即在该节点上形成链表。当新的节点插入链表时，java8之前是头插法，java8之后变为尾插法，主要防止哈希表扩容时，头插法易形成循环链表。</p><h1 id="为何JAVA8之后改为尾插法？"><a href="#为何JAVA8之后改为尾插法？" class="headerlink" title="为何JAVA8之后改为尾插法？"></a>为何JAVA8之后改为尾插法？</h1><p>首先来看看HashMap的扩容机制：</p><blockquote><p>数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize.</p><p>一般有两个因素：Capacity–HashMap当前长度       LoadFactor–负载因子，默认值0.75f</p><p>即假设当前的容量大小为100，当存进第76个元素的时候，判断发现需要对哈希表进行resize。</p></blockquote><p>具体扩容分为两步进行：</p><p>  <strong>扩容</strong>：创建一个新的空数组，长度是原数组的2倍</p><p>  <strong>rehash</strong>：遍历原数组，把所有节点重新Hash到新数组</p><blockquote><p>为何要重新hash节点插入？直接复制更快？</p><p>因长度扩容之后，数组长度改变，Hash的规则也会随之改变</p></blockquote><p>具体到为什么改为尾插法更好，使用头插法，容量为2的容器，某一节点上链表A-B-C在不同线程扩容插入A,B,C时，可能会形成B-A-B的回环，而使用尾插不会改变链表上的顺序，扩容时即不会出现链表成环问题。由此JAVA8不会出现像JAVA7在多线程操作哈希表时的死循环问题。</p><p>但这并不说明JAVA8可以任意把哈希表使用在多线程中，通过源码可知put/get方法均没有加同步锁，还是无法保证上一秒put的值，下一秒get还是原值，即线程安全还是无法保证。</p><blockquote><p>哈希表的默认初始化长度是16        为经验值</p></blockquote><h1 id="为何重写equals方法要重写hashCode方法？"><a href="#为何重写equals方法要重写hashCode方法？" class="headerlink" title="为何重写equals方法要重写hashCode方法？"></a>为何重写equals方法要重写hashCode方法？</h1><p>java中所有的对象都是继承于Object类，而Ojbect类中有两个比较两个对象是否相等的方法：equals和hashCode。</p><p>而哈希表找到数组同一节点上的链表时，使用equals比较链表上不同的值，也就是说我们一定要对hashCode进行重写，以保证<strong>相同的对象返回相同的hash值，不同的对象返回不同的hash值</strong>。</p><h1 id="HashMap为何是线程不安全的"><a href="#HashMap为何是线程不安全的" class="headerlink" title="HashMap为何是线程不安全的"></a>HashMap为何是线程不安全的</h1><h2 id="jdk1-7中HashMap"><a href="#jdk1-7中HashMap" class="headerlink" title="jdk1.7中HashMap"></a>jdk1.7中HashMap</h2><p>原因一：扩容造成死循环</p><p>在对哈希表进行扩容时，扩容函数将原数据转移到新表中，也会使用头插法，造成链表顺序翻转，多线程情况下这里是形成死循环的关键点。</p><p>原因二：扩容造成数据丢失</p><p>在扩容时，也可能造成数据丢失，数据指向自己，形成自环</p><h2 id="jdk1-8中的HashMap"><a href="#jdk1-8中的HashMap" class="headerlink" title="jdk1.8中的HashMap"></a>jdk1.8中的HashMap</h2><p>在jdk1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，因此不会出现环形链表的情况，但是在多线程的情况下仍然不安全。诸如不同线程的put相互覆盖的情况。</p><h1 id="如何处理HashMap在线程不安全的情况"><a href="#如何处理HashMap在线程不安全的情况" class="headerlink" title="如何处理HashMap在线程不安全的情况"></a>如何处理HashMap在线程不安全的情况</h1><p>一般使用<strong>HashTable</strong>或者<strong>CurrentHashMap</strong>。</p><blockquote><p>虽然Hashtable和HashMap相比是线程安全的，但其在对数据操作时都会上锁，存在效率问题。另外<strong>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null</strong>。</p></blockquote><h1 id="ConcurrentHashMap如何保证线程安全？"><a href="#ConcurrentHashMap如何保证线程安全？" class="headerlink" title="ConcurrentHashMap如何保证线程安全？"></a>ConcurrentHashMap如何保证线程安全？</h1><p>ConcurrentHashMap的存值put步骤如下：</p><ol><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p></li></ol><p>ConcurrentHashMap的取值get步骤如下：</p><ol><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ol><h1 id="何为CAS，何为自旋？"><a href="#何为CAS，何为自旋？" class="headerlink" title="何为CAS，何为自旋？"></a>何为CAS，何为自旋？</h1><p>CAS 是乐观锁的一种实现方式，为一种轻量级的锁，认为并发操作并不总会发生。</p><p>具体流程为：线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p><p>但其不能检测ABA问题，即A被某线程修改为B，再被某线程修改回A。乐观锁CAS无法检测。</p><h1 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h1><h1 id="synchronized锁升级策略"><a href="#synchronized锁升级策略" class="headerlink" title="synchronized锁升级策略"></a>synchronized锁升级策略</h1>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《九零》（外两首）</title>
    <link href="/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/"/>
    <url>/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>​                        <strong>《九零》</strong></p><p>哨响冬末三九天，心系楚地八方援。</p><p>才笑九零纨绔子，挑灯提剑奔在前。</p><p>欲使天下除病事，敢为家国争人先。</p><p>满腔抱负今犹在，我辈英才正少年。</p><hr><p>才备腊酒留家宴，满城闭户锁门帘。</p><p>岁末不知春尚早，风将吹落谁家檐？</p><p>白衣同往御风雪，万民共载世多贤。</p><p>但看春光明媚去，家人闲坐笑谈天</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--判断回文数</title>
    <link href="/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目：判断一个数是否是回文数，12321是，但负数肯定不是，简单来说，排除负数后，判断整数反转后是否等于自身即可</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">boolean</span> <span class="hljs-title">huiwen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;       <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;       <span class="hljs-keyword">int</span> copyx=x,reverse=<span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span>(copyx!=<span class="hljs-number">0</span>)&#123;           reverse=reverse*<span class="hljs-number">10</span>+copyx%<span class="hljs-number">10</span>;           copyx/=<span class="hljs-number">10</span>;       &#125;       <span class="hljs-keyword">return</span> x==reverse;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--整数反转</title>
    <link href="/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>题目：将整数按位反转，注意若反转后数溢出则返回0</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(;x!=<span class="hljs-number">0</span>;x/=<span class="hljs-number">10</span>)        res = res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;    <span class="hljs-keyword">return</span> res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE?<span class="hljs-number">0</span>;(<span class="hljs-keyword">int</span>) res;&#125;循环部分等价于    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;        res=res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;        x=x/<span class="hljs-number">10</span>;    &#125;</code></pre><p><strong>Integer.MAX_VALUE和Integer.MIN_VALUE分别是整数int的最大和最小值</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--罗马数字转换</title>
    <link href="/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>题目：将罗马数字字符串转换为数字，当小字符在大字符前的时候，结果为大数减小数，如IV=4,IV=9</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">romantoInt</span><span class="hljs-params">(String s)</span></span>&#123;    Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>);    map.put(<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>);    map.put(<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>);    map.put(<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>);    map.put(<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>);    map.put(<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>);    map.put(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>);    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span> sum = map.get(s.charAt(len-<span class="hljs-number">1</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;        <span class="hljs-keyword">if</span>(map.get(s.charAt(i))&lt;map.get(s.charAt(i+!)))&#123;            sum=sum-map.get(s.charAt(i));        &#125;<span class="hljs-keyword">else</span>        &#123;            sum=sum+map.get(s.charAt(i));        &#125;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--两数求和</title>
    <link href="/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <url>/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目：两数求和返回下标，例如[2,7,11,15],目标值target=9，结果返回[0,1]</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"> Public <span class="hljs-keyword">int</span> [] towsum(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)&#123; <span class="hljs-keyword">int</span> len = nums.length;​HashMap&lt;Integer,Integer&gt; map= <span class="hljs-keyword">new</span> HashMap&lt;&gt;();​<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;++i)&#123;​<span class="hljs-keyword">final</span> Integer value = map.get(nums[i]);​<span class="hljs-keyword">if</span>(value!=<span class="hljs-keyword">null</span>)&#123;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;value,i&#125;;​&#125;​map.put(target-nums[i],i);​&#125;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p><strong>使用哈希表，键存target-nums[i]差值，值存相对应下标，若遍历时已存在，则返回目标对应值和当前下标</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图神经网络综述</title>
    <link href="/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/"/>
    <url>/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="图神经网络综述"><a href="#图神经网络综述" class="headerlink" title="图神经网络综述"></a>图神经网络综述</h1><h2 id="GNN简介与起源"><a href="#GNN简介与起源" class="headerlink" title="GNN简介与起源"></a>GNN简介与起源</h2><p>​        关于GNN的起源来自于两种思维的碰撞，一种是卷积神经网络CNN，另一种是图嵌入（graph embedding）。众所周知，CNN擅长提取多尺度的局部特征并将其组合为更高级的表示。CNN的核心特点是局部链接，权重共享，多层叠加。类推可以发现，这些特点可良好移植到图结构中。首先，图结构是最典型局部连接结构；其次，共享权重可减少计算量；最后，多层结构保证了分级处理问题的可能。但局限的是，CNN只能良好处理欧几里得数据，诸如一维文本数据和二维图像数据，这些数据都可以看作规则连接的图结构特例。对于图结构，CNN的卷积核和池化操作很难迁移到图上。图嵌入就是对图的节点，边或子图进行学习得到一个低维的向量表示。图嵌入常见模型由DeepWalk，Node2Vec等，但这些方法普遍有严重不足，一是节点编码中权重未进行共享而导致权重数量随着节点增多线性增大。再是直接嵌入方法缺乏泛化能力，无法将模型泛化到处理新的图。基于此，两者结合，提出了图神经网路GNN。</p><h2 id="GNN与传统NN区别"><a href="#GNN与传统NN区别" class="headerlink" title="GNN与传统NN区别"></a>GNN与传统NN区别</h2><p>​        传统神经网络诸如CNN和RNN因都需要节点的特征按照一定的顺序排列，而图结构并没有特定的顺序，导致它们不能适当处理图结构输入。若将图拆分为所有可能的多个序列，将会造成非常大的计算冗余。GNN采用在每个节点上分别进行传播的方式进行学习，由此忽略节点顺序，从而GNN输出会随着输入的不同而不同。另外，GNN通过邻居节点的加权求和来更新节点隐藏状态。传统神经网络主要处理的数据对象是欧式空间的，例如文本序列，图片等等，而图神经网络主要是处理非欧空间的数据，例如社群关系，知识图谱等。具体到图神经网络的两种实现形式，第一种是将非欧空间的图转换为欧式空间的图，也就是基于谱域的实现，另一种是直接在图上抽特征，随机游走等的方式来做的，就是基于空域的实现。</p><h2 id="GNN分类"><a href="#GNN分类" class="headerlink" title="GNN分类"></a>GNN分类</h2><p>​    从空域视角看图卷积神经网络，本质上是一个迭代式聚合邻居的过程，这一行为启发了一大类模型对聚合操作的重新设计，这些设计在某些方面大大加强了图神经网络对图数据的适应性，下面对图神经网络的典型变体和通用表达框架进行介绍。</p><h3 id="GraphSAGE"><a href="#GraphSAGE" class="headerlink" title="GraphSAGE"></a>GraphSAGE</h3><p>​        GraphSAGE从两个方面对GCN进行了改动，一方面是通过采样邻居策略将GCN由全图训练方式改造成以节点为中心的小批量训练，这使得大规模图数据的分布式训练变得可能。另一方面对聚合邻居的操作进行了扩展，提出了替换GCN操作的几种新的方式。</p><p>​        在之前的GCN模型中，训练方式是一种全图形式，也就是一轮迭代，所有节点样本的损失只会贡献一次梯度数据，无法做到DNN中常用的小批量式更新，这是很低效的。GraphSAGE从聚合邻居出发，对邻居进行随机采样来控制实际运算时节点K阶子图的数据规模，在此基础上对采样的子图进行随机组合来完成小批量式的训练。在GCN中，节点在k+1层的特征只与其邻居在K层的特征有关，即节点在第k层的特征只与自己的K阶子图有关。GraphSAGE研究了几种新的聚合方法，即对聚合节点数量自适应，使聚合操作对聚合节点具有排列不变性。总之，GraphSAGE对空域视角下的GCN做了一次解构，提出了几种邻居的聚合操作算子，同时通过采样邻居，大大提高了算法的工程价值。在引文[61]中通过该方法完成了对工业级大规模推荐系统的应用，且效果十分显著。</p><h3 id="图注意力网络GAT"><a href="#图注意力网络GAT" class="headerlink" title="图注意力网络GAT"></a>图注意力网络GAT</h3><p>​        图注意力网络通过注意力机制对邻居节点做聚合操作，实现了对不同邻居权重的自适应分配，从而大幅提高图神经网络的表达能力。图注意力网络通过注意力机制来对邻居节点做聚合操作，实现对不同邻居权重的自适应分配，从而大大提高了图神经网络模型的表达能力。</p><p>​        DNN中的注意力机制是通过人对信息处理机制的轻重来启发的。注意力机制的核心在于对给定信息进行权重分配，权重高的信息意味着需要系统进行重点加工。注意力机制里包含三要素：Query，Source，Attention Value。即当前中心节点的特征向量，所有邻居的特征向量，中心节点经过聚合操作后的新的特征向量。具体到网络结构中，图注意力层比GCN里的图卷积层多了一个自适应的边权重系数维度。</p><h3 id="GNN的General-Framework"><a href="#GNN的General-Framework" class="headerlink" title="GNN的General Framework"></a>GNN的General Framework</h3><p>（1）消息传播神经网络MPNN</p><p>MPNN通过消息传播机制对多种GCN模型做出一般化总结。其基本思路为：节点的表示向量都是通过消息函数M和更新函数U进行K轮消息传播机制的迭代后得到。MPNN的核心在于消息函数和更新函数，原则上可以把他们设计成任意一种DNN模型，MPNN的消息函数是作用在RDF三元组上，因此对于常见的同构图，异构图，属性图等都具有一定的适应性。</p><p>（2）非局部神经网络NLNN</p><p>非局部神经网络NLNN是对注意力机制的一般化总结，GTA即为其一个特例。NLNN通过non-local操作将任意位置的输出响应计算为所有位置特征的加权和。位置可以是图像中的空间坐标，也可以是序列数据中的时间坐标，在图数据中，位置可以直接以节点替代。</p><p>（3）图网络GN</p><p>Graph Network是比MPNN和NLNN，对GNN的更一般的总结，基本计算单元包含三个元素，节点的状态，边的状态，图的状态。GN对图里面的节点，边，图全都维护了相应的状态，这三者可分别对应节点层面的任务，边层面的任务，全图层面的任务，这也就是说GN可依据图数据以及相关任务的实际情况，对GN进行相应的简化处理。</p><h2 id="GNN应用"><a href="#GNN应用" class="headerlink" title="GNN应用"></a>GNN应用</h2><h3 id="网络分析"><a href="#网络分析" class="headerlink" title="网络分析"></a>网络分析</h3><p>​        在社会网络分析领域，引文网络是最为常见的数据，即节点为论文，连边关系为引用关系，常见的数据集包括Cora，DBLP，Citeseer等.这些常见的网络的数据集的描述如表1以所示。一个典型的分类任务是给定每篇文章的内容信息和文章之间的引用关系，将每篇文章分类到对应的领域中．例如，在节点的半监督分类场景下，已知节点的属性信息包括文章的标题或摘要信息，以及节点之间的引用关系构成的网络信息， 给定少量的数据标签，通过机器学习的方式，对网络中的每个节点的所属领域进行划分．在该任务中，图卷积神经网络将节点文本属性和引用网络结构有效的建模，取得了巨大的成功。</p><h3 id="交通预测"><a href="#交通预测" class="headerlink" title="交通预测"></a>交通预测</h3><p>​        交通预测问题也是图卷积神经网络得到广泛应用的任务之一．其目的是在给定历史交通速度和路线图的情况下，预测未来的交通的速率．在交通预测问题中，节点表示在道路中放置的传感器，而边则表示节点对的物理距离．每个节点包含一个时序的特征．相比于传统的图分析问题．交通预测问题中包括时间和空间两个方面的建模，而如何利用图卷积神经网络更好地建模交通中的路网带来了机遇和挑战。</p><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><p>​        图卷积神经网络被认为能够很好地建模图的结构属性和节点特征信息，而推荐系统既可以被视为一个矩阵补全问题， 也可以被视为是二部图（ 用户和商品） 的链接预测问题．相比传统的方法，图卷积神经网络能够更好地利用在推荐系统中普遍存在的用户属性和商品属性信息，这也是图卷积神经网络能够在推荐系统任务上引起人们广泛关注的原因。</p><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>​        图卷积神经网络在计算机视觉中的应用，主要用在少样本学习，零样本学习，点云建模等领域。在图片分类方面，主要创新在零样本学习和少样本学习上的表现，在计算机视觉领域，研究者在完成包括物体识别，图片分类，语义分割过程中，更多关注物体在少量样本或复杂语义情况下的建模和学习过程，对图关联的注意较少，而图卷积神经网络着重关注了此方面，是对图数据建模的有效方法。</p><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>​        图卷积神经网络在自然语言处理领域有大量的应用．在该领域中， 较为常见的图数据为知识图谱、句法依赖图和抽象含义表达图、词共现图以及其他方式构建的图．抽象含义表达（即AMR）是一种将一个句子的含义编码为有根有向图．在使用图卷积神经网络模型后，各项自然语言处理任务的结果都出现了一定的提升。图结构的使用，使得对象之间的复杂的语义关系得到了有效地挖掘。相比传统的对于自然语言处理的序列化建模，使用图卷积神经网络能够挖掘出非线性的复杂语义关系。</p><h3 id="生物化学"><a href="#生物化学" class="headerlink" title="生物化学"></a>生物化学</h3><p>​        除了传统的图数据的建模外，图卷积神经网络在生物化学等领域也受到了研究人员的大量关注。相比传统的图数据的研究，在生物化学领域，人们通常将一个化学结构或一个蛋白质视为一个图，图中的节点是更小的分子，边代表键或者相互作用。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
      <tag>GCN</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
