<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis学习笔记(二)</title>
    <link href="/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <url>/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote><p>传统的关系型数据库如Mysql等已不能适用所有场景，如秒杀的库存扣减，APP的首页访问流量高峰等，这些情况都很容易把数据库打崩，所有Redis作为缓存中间件横空出世。</p></blockquote><h2 id="缓存穿透与布隆过滤器"><a href="#缓存穿透与布隆过滤器" class="headerlink" title="缓存穿透与布隆过滤器"></a>缓存穿透与布隆过滤器</h2><blockquote><p>判断不存在的数据没有必要让Mysql再次查询，Redis利用布隆过滤器挡下那些明显不会有结果的查询请求。</p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器可以用于检索一个元素是否再一个集合中，其优点是空间效率和查询时间都远超一般算法，但有一定的误识别率和删除困难。</p><h3 id="布隆过滤器基本原理"><a href="#布隆过滤器基本原理" class="headerlink" title="布隆过滤器基本原理"></a>布隆过滤器基本原理</h3><p>布隆过滤器本质为bitmap位数组的扩展。例如有0-31范围的25个不重复数字，如何判断18在不在其中?</p><ol><li>第一种做法是建立数字数组，使用int8单字节数组，需要8*32=256位，即32字节的空间。</li><li>第二种做法使用一个int32的变量，该变量4个字节，可用bit0表示数字0，bit1表示数字1，。。。依次类推。即知我们使用4字节空间就完成了方法一32字节的工作。</li></ol><h4 id="布隆过滤器两大组件"><a href="#布隆过滤器两大组件" class="headerlink" title="布隆过滤器两大组件"></a>布隆过滤器两大组件</h4><blockquote><ol><li>一定大小的BitAarry位阵列（具体大小与存储规模相关）</li><li>N个可用的哈希函数（N的个数与存储规模，容忍误判率等有关）降低哈希冲突，尽量选用优秀的哈希函数。</li></ol></blockquote><p>两组件分工为，位阵列存储对应位的值是0/1的二进制向量，哈希函数将原始输入经过数字运算转换为一个数字值。</p><h4 id="布隆过滤器与哈希冲突"><a href="#布隆过滤器与哈希冲突" class="headerlink" title="布隆过滤器与哈希冲突"></a>布隆过滤器与哈希冲突</h4><p>哈希冲突虽然概率很低，但是在大规模数据场景下还是会出现，可尽量选用表现更优秀的哈希函数，或者多个哈希共同使用。</p><h4 id="布隆过滤器的具体使用"><a href="#布隆过滤器的具体使用" class="headerlink" title="布隆过滤器的具体使用"></a>布隆过滤器的具体使用</h4><p>假设三个哈希函数h1，h2，h3，有三个输入a,b,c已存在，分别通过三个哈希函数计算出对应整数后，对bitarray长度取模后将对应位置置1.</p><p>当布隆过滤器检索时，使用相同哈希函数进行计算，只要对应位置中，任何一个位置有0，则被检元素一定不存在，若对应位置都是1，则被检元素可能存在。</p><p>网上找图，如下所示：</p><p><img src="/img/bulong.png"></p><blockquote><p><strong>有0一定不存在，全1不一定存在</strong></p></blockquote><blockquote><p>所以布隆过滤器存在一定的误判，主要因素包括：</p><ol><li>哈希函数本身的冲突率</li><li>bitarray位数组的大小</li></ol></blockquote><blockquote><p>因为对位置重复赋值，所以一般不能从布隆过滤器删除元素</p></blockquote><h2 id="布隆过滤器的典型应用"><a href="#布隆过滤器的典型应用" class="headerlink" title="布隆过滤器的典型应用"></a>布隆过滤器的典型应用</h2><ol><li>缓存穿透过滤</li><li>检查单词拼写正确性</li><li>垃圾邮件过滤:如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</li><li>检查海量名单嫌疑人</li><li>搜索爬虫URL去重:爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记(一)</title>
    <link href="/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis是一个完全开源的高性能key-value数据库.</p><h2 id="Redis的数据结构与应用场景"><a href="#Redis的数据结构与应用场景" class="headerlink" title="Redis的数据结构与应用场景"></a>Redis的数据结构与应用场景</h2><blockquote><p>使用场景:缓存,共享session,消息队列系统,分布式锁</p></blockquote><blockquote><p>单线程Redis快的原因?</p><ol><li>纯内存操作</li><li>单线程操作,避免了频繁上下文切换</li><li>合理高效的数据结构</li><li>采用非阻塞I/O多路复用机制</li></ol></blockquote><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><p>字符串是Redis最基础的数据结构.其中键都是字符串类型,剩下几种数据结构都是在字符串类型基础上构建的.常用在缓存,计数,共享session,限速等方面.</p><h3 id="Hash哈希"><a href="#Hash哈希" class="headerlink" title="Hash哈希"></a>Hash哈希</h3><p>Redis中,哈希类型是指键值本身又是一个键值对结构的数据.可用来存放用户信息,实现诸如购物车等功能.</p><h3 id="List列表-双向链表"><a href="#List列表-双向链表" class="headerlink" title="List列表(双向链表)"></a>List列表(双向链表)</h3><p>列表类型可用来存储多个有序的字符串,可做简单的消息队列功能.</p><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>集合类型可用来保存多个的字符串元素,与列表不同的是,集合中不允许重复元素且元素无序,不能通过索引下标获取元素.可通过Set的交集,并集,差集等来计算重合元素.</p><h3 id="Sorted-Set有序集合"><a href="#Sorted-Set有序集合" class="headerlink" title="Sorted Set有序集合"></a>Sorted Set有序集合</h3><p>相对Set多了一个权重参数Score,集合中元素能按Score进行排列.常用来做排行榜,取Top N.</p><h2 id="Redis的数据过期策略"><a href="#Redis的数据过期策略" class="headerlink" title="Redis的数据过期策略"></a>Redis的数据过期策略</h2><blockquote><p>Redis中数据过期策略采用定期删除与惰性删除策略</p></blockquote><h3 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h3><p>Redis会启动一个定时器定时监视所有key，判断key的时效性，若过期即删除key。此方法能保证过期的key最终都能被删除。但本方法每次都要遍历内存中所有数据，非常消耗CPU资源。并且当Key过期后，定时器还未被唤起，这一段时间内的key仍然可用。</p><h3 id="惰性删除策略"><a href="#惰性删除策略" class="headerlink" title="惰性删除策略"></a>惰性删除策略</h3><p>在获取到key时，判断key是否过期，若过期则删除。本方法缺点是：若某个key一直未被使用，则其将会一直在内存中，占用空间。</p><h3 id="两者结合策略"><a href="#两者结合策略" class="headerlink" title="两者结合策略"></a>两者结合策略</h3><p>定时删除策略不再扫描全部key。而是随机抽取部分key进行检查，从而降低对CPU的损耗。惰性删除策略弥补了可能未被检查到的key。若还是存在过期的key，既没有被定时器抽取，也没有被使用，则当内存不够时，使用内存淘汰机制进行淘汰。</p><blockquote><p>移除最近最少使用的key/随机移除某个key </p><p>LRU（Least Recently Used) 最近最少使用</p></blockquote><h4 id="如何实现LRU"><a href="#如何实现LRU" class="headerlink" title="如何实现LRU"></a>如何实现LRU</h4><p>一般使用HashMap和双向链表实现LRU。使用HashMap存储key，而value指向双向链表实现的LRU的Node节点，如图：</p><p><img src="/img/LRU.png"></p><p>h表头，t表尾，预先设置LRU的容量。若存储满了，则O（1）时间淘汰掉双向链表的表尾。每次访问数据，都可通过O（1）效率把新节点增加到队头或把已存在点移动到队头。</p><h4 id="Redis的LRU具体实现"><a href="#Redis的LRU具体实现" class="headerlink" title="Redis的LRU具体实现"></a>Redis的LRU具体实现</h4><p>Redis每次按key获取一个值时，都会更新value中的LRU字段为当前秒级别的时间戳。</p><p>第一版LRU为，随机从dict中取出五个key，淘汰一个LRU最小的。</p><p>在3.0时，改进一版算法，首先第一批随机挑选的key会放进一个pool中（默认大小16），pool中的key是按LRU字段大小顺序排列。接下来每次随机挑选的key的LRU必须小于pool的最小LRU才会继续放入，直至pool放满。放满后，若有新的key需要放入，则将pool中LRU最大的key取出。淘汰的时候，直接从pool中选取LRU最小的值进行淘汰即可。</p><h2 id="Redis如何发现热点key"><a href="#Redis如何发现热点key" class="headerlink" title="Redis如何发现热点key"></a>Redis如何发现热点key</h2><p>Redis主要有五种发现热点key的方法：</p><ol><li>凭借经验预估：提前知道某个活动的开启，将该key作为热点key。</li><li>服务端收集：在操作redis前，加入计数代码进行数据统计。</li><li>抓包评估：Redis使用TCP协议与客户端通信，通信协议采用RESP，即自己写程序监听端口能进行拦截包分析。</li><li>在proxy层，对每个redis请求进行收集上报。（proxy–代理服务器）</li><li>Redis自带命令查询：Redis4.0.4版本后，使用命令redis-cli-hotkeys能找出热点key</li></ol><h3 id="Redis缓存雪崩问题的解决"><a href="#Redis缓存雪崩问题的解决" class="headerlink" title="Redis缓存雪崩问题的解决"></a>Redis缓存雪崩问题的解决</h3><ol><li>使用Redis高可用框架：使用 Redis 集群来保证 Redis 服务不会挂掉。</li><li>缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效。</li><li>限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务。</li></ol><h3 id="Redis缓存穿透问题的解决（待详细展开）"><a href="#Redis缓存穿透问题的解决（待详细展开）" class="headerlink" title="Redis缓存穿透问题的解决（待详细展开）"></a>Redis缓存穿透问题的解决（待详细展开）</h3><ol><li>在接口做校验。</li><li>缓存击穿加锁/设置不过期</li><li>布隆过滤器拦截</li></ol><h2 id="Redis的几种集群模式"><a href="#Redis的几种集群模式" class="headerlink" title="Redis的几种集群模式"></a>Redis的几种集群模式</h2><blockquote><ol><li>主从复制</li><li>哨兵模式</li><li>cluster模式</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记(一)</title>
    <link href="/2020/12/01/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2020/12/01/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="事务的基本要素"><a href="#事务的基本要素" class="headerlink" title="事务的基本要素"></a>事务的基本要素</h2><blockquote><p>原子性,一致性,隔离性,持久性——-ACID</p></blockquote><ol><li>原子性(atomicity),即事务是一个原子操作单元,对数据的修改,要么全部执行,要么全部不执行</li><li>一致性(consistency),即事务开始与结束前,数据库的完整性约束未被破坏</li><li>隔离性(isolation),即同一时间,只允许一个事务请求同一数据,不同事务间没有任何干扰</li><li>持久性(durability),即事务完成后,事务对数据库的所有更新将被保存到数据库,不能回滚</li></ol><h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><blockquote><p>脏读,不可重复读,幻读</p></blockquote><ol><li><p>脏读,即事务A读取了事务B更新的数据,然后B进行了回滚,那A读取到的数据是脏数据</p></li><li><p>不可重复读,即事务A多次读取同一数据,事务B在A多次读取过程中,对数据做了更新并提交,导致A多次读取的内容不一致</p></li><li><p>幻读,即事务A读取了事务B已提交的新增数据.也是重复读取不一致.</p><blockquote><p>幻读是新增数据,不可重复读是更改数据.</p></blockquote></li></ol><h2 id="Mysql事务的隔离级别"><a href="#Mysql事务的隔离级别" class="headerlink" title="Mysql事务的隔离级别"></a>Mysql事务的隔离级别</h2><blockquote><p>读未提交:可以读到未提交的内容,可能产生脏读,不可重复读,幻读</p><p>不可重复读(读提交):只能读到已提交的内容</p><p>可重复读:查询事务启动时,不允许进行更改操作了,为Mysql的默认隔离级别</p><p>串行化: 数据库最高隔离级别,事务必须一个一个排队执行,按串行化顺序</p><ol><li>为何出现脏读?   select操作没有规矩</li><li>为何出现不可重复读?  update操作没有规矩</li><li>为何出现幻读?   insert和delete没有规矩</li></ol></blockquote><table><thead><tr><th align="center">事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td>是</td><td>是</td><td>是</td></tr><tr><td align="center">不可重复读(读提交)</td><td>否</td><td>是</td><td>是</td></tr><tr><td align="center">可重复读</td><td>否</td><td>否</td><td>是</td></tr><tr><td align="center">串行化</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h2 id="sql语句执行顺序"><a href="#sql语句执行顺序" class="headerlink" title="sql语句执行顺序"></a>sql语句执行顺序</h2><p>from</p><p>where</p><p>group by</p><p>having</p><p>select</p><p>order by</p><h2 id="Mysql的存储引擎"><a href="#Mysql的存储引擎" class="headerlink" title="Mysql的存储引擎"></a>Mysql的存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>是基于聚簇索引建立的,其支持事务,外键,并且通过MVCC来支持高并发以及索引数据一体存储.Mysql5.5.8版本后成为默认存储引擎</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>为5.1版本前的默认引擎,支持全文检索,压缩,空间函数,但不支持事务和行级锁,一般用在大量查询少量插入的场景,且不支持外键,其索引和数据是分开存储的</p><h2 id="Mysql的逻辑结构"><a href="#Mysql的逻辑结构" class="headerlink" title="Mysql的逻辑结构"></a>Mysql的逻辑结构</h2><blockquote><p>最上层服务类似CS结构,进行连接处理,授权处理</p></blockquote><blockquote><p>第二层为Mysql服务层,SQL语句的解析分析优化,存储过程触发器视图等都在本层实现</p></blockquote><blockquote><p>最下层为存储引擎的实现,类似Java接口实现,在调用时会屏蔽不同引擎实现间的差异</p></blockquote><h2 id="Mysql的日志系统"><a href="#Mysql的日志系统" class="headerlink" title="Mysql的日志系统"></a>Mysql的日志系统</h2><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>即回滚日志文件,主要用于事务执行失败,进行回滚,在MVCC中对数据历史版本查看.由引擎层的InnoDB引擎实现,为逻辑日志,记录数据被修改前的值.保证了事务的一致性</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>即重做日志文件,记录数据修改后的值,用于持久化到磁盘中,由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息(诸如某个数据页上的内容发生改动).当某条数据需要更新,InnoDB会先将数据更新,然后记录redo log在内存中,找个时间将redo log操作执行到磁盘文件上.不管提交是否成功,都会记录,若进行回滚操作,也会记录回滚.保证了事务的持久性.</p><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h3><p>是Mysql中基于乐观锁理论实现隔离级别的方式,用于读提交和可重复读隔离级别的实现.在Mysql中,会在表中每条数据后添加两个字段:<strong>最近修改改行数据的事务ID</strong>和<strong>指向改行回滚段(undolog)的指针</strong>.实际上为保存了数据在某个时间节点的快照.</p><h3 id="binlog与redo-log区别"><a href="#binlog与redo-log区别" class="headerlink" title="binlog与redo log区别"></a>binlog与redo log区别</h3><ol><li>redo log是在InnoDB存储引擎层产生,而binlog是MySQL数据库的上层服务层产生</li><li>两种日志记录内容形式差异.binlog是逻辑日志,记录对应的sql语句和事务;而redo log是物理日志,记录的是关于每个页的更改的物理情况</li><li>两种日志的记录写入磁盘的时间点不同,binlog只在事务提交完成后进行一次写入.而redo log在事务进行中不断被写入.</li><li>binlog不是循环使用,在写满或重启后,才会生成新的binlog文件,redo log是循环使用</li><li>两者都能进行数据恢复.</li></ol><h2 id="Mysql如何保证一致性和持久性"><a href="#Mysql如何保证一致性和持久性" class="headerlink" title="Mysql如何保证一致性和持久性"></a>Mysql如何保证一致性和持久性</h2><p>为保证ACID中的一致性和持久性,使用了先写日志再写磁盘的操作,即WAL(write-Ahead logging)</p><p>当数据库断电再重新启动时,mysql可以通过redo log还原数据;即只要在每次事务刷新时,同步刷新redo log即可,不用同步刷新磁盘数据文件.</p><h2 id="Mysql锁的类型"><a href="#Mysql锁的类型" class="headerlink" title="Mysql锁的类型"></a>Mysql锁的类型</h2><p>mysql的锁分为共享锁和排他锁,即读锁和写锁.</p><p>读锁为共享的,可通过lock in share mode实现,只能读不能写</p><p>写锁为排他的,会阻塞其他的写锁和读锁.</p><p>另外,通过颗粒度来分,又分为表锁和行锁两种.</p><p>其中表锁会锁定整张表并阻塞其他用户对该表所有的读写操作.阻塞诸如alter修改表结构等的操作</p><p>行锁又可分为乐观锁和悲观锁两种,悲观锁通过for update实现,乐观锁通过版本号实现.</p><h3 id="InnoDB的行锁模式"><a href="#InnoDB的行锁模式" class="headerlink" title="InnoDB的行锁模式"></a>InnoDB的行锁模式</h3><ol><li>共享锁(S):用法即lock in share mode,允许一个事务去读一行,阻止其他数据获得相同数据的排他锁.意思是,若事务1对数据对象A加了S锁,事务1可以读A但不能修改A,其他事务对A也只能加S锁,而不能加X锁,直至事务1释放A上的S锁</li><li>排他锁(X):用法for update,允许获取排他锁事务更新数据,阻止其他事务对相同数据加锁.若事务1对数据A进行加锁,其他事务不能再对A加任何锁.</li></ol><blockquote><p>在没有索引的情况下,InnoDB只能使用表锁</p></blockquote><h2 id="Mysql的索引"><a href="#Mysql的索引" class="headerlink" title="Mysql的索引"></a>Mysql的索引</h2><blockquote><p>索引按照数据结构来讲,主要包含B+树和Hash索引</p></blockquote><h3 id="为什么选择B-树为索引结构"><a href="#为什么选择B-树为索引结构" class="headerlink" title="为什么选择B+树为索引结构"></a>为什么选择B+树为索引结构</h3><ul><li>Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</li><li>二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。</li><li>平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。</li><li>红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。</li><li>B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效</li></ul><h3 id="B-树的叶子节点都可以存哪些东西"><a href="#B-树的叶子节点都可以存哪些东西" class="headerlink" title="B+树的叶子节点都可以存哪些东西"></a>B+树的叶子节点都可以存哪些东西</h3><p>可能存储的是整行数据，也有可能是主键的值。B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引</p>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--括号匹配</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><blockquote><p>可以考虑使用数组来模拟栈操作，另外让top=1，省去判断栈空，和数组越界的问题</p><p>在遇到）时，判断栈顶是否是（，以此类推</p></blockquote><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">boolean</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(String s)</span></span>&#123;    <span class="hljs-keyword">char</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[s.length()+<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> top=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:s.toCharArray())&#123;        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;(&#x27;</span>||c==<span class="hljs-string">&#x27;[&#x27;</span>||c==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;            stack[top++]=c;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;）&#x27;</span>&amp;&amp;stack[--top]!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;stack[--top]!=<span class="hljs-string">&#x27;[&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;&#123;&#x27;</span>&amp;&amp;stack[--top]!=<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> top==<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--移除有序数组重复元素</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="移除有序数组重复元素"><a href="#移除有序数组重复元素" class="headerlink" title="移除有序数组重复元素"></a>移除有序数组重复元素</h1><blockquote><p>题目:移除有序数组重复元素，返回剩余元素个数。例如[1,1,2,2,3],返回3</p><p>使用一个指针指向头部，进行赋值</p></blockquote><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span>(len&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> len;    <span class="hljs-keyword">int</span> tail = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;len;++i)&#123;        <span class="hljs-keyword">if</span>(nums[i-<span class="hljs-number">1</span>]!=nums[i])&#123;            nums[tail++]=nums[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> tail;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--寻找子串</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找子串"><a href="#寻找子串" class="headerlink" title="寻找子串"></a>寻找子串</h1><blockquote><p>题目:在一字符串中寻找子串，返回子串首字母索引，若未找到返回-1。</p><p>即找到在s1中遍历完s2的位置可求解</p><p>例如，s1=hello，s2=ll，则返回2</p></blockquote><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">strstr</span><span class="hljs-params">(String s1,String s2)</span></span>&#123;    <span class="hljs-keyword">int</span> l1= s1.length(),l2=s2.length();    <span class="hljs-keyword">if</span>(l1&lt;l2) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;;i++)&#123;        <span class="hljs-keyword">if</span>(i+l2&gt;l1) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;     <span class="hljs-comment">//剩余长度不足以遍历完</span>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;;j++)&#123;            <span class="hljs-keyword">if</span>(j=l2) <span class="hljs-keyword">return</span> i;   <span class="hljs-comment">//遍历完s2情况</span>            <span class="hljs-keyword">if</span>(s1.charAt(i+j)!=s2.charAt(j))                <span class="hljs-keyword">break</span>;        &#125;    &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--寻找插入位置</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找插入位置"><a href="#寻找插入位置" class="headerlink" title="寻找插入位置"></a>寻找插入位置</h1><blockquote><p>题目:从一个无重复元素已排序数组找到插入位置索引。例如，[1,3,5,6],插入数字2，即返回1；[1，3，5，6] 插入数字5，即返回2；</p></blockquote><p>可通过二分查找找到第一个大于等于target元素位置</p><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)</span></span>&#123;    <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>,mid = (right+left)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;        <span class="hljs-keyword">if</span>(target&lt;=nums[mid])&#123;            right=mid-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            left = mid+<span class="hljs-number">1</span>;        &#125;        mid = (right+left)&gt;&gt;<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--跳水板拼凑</title>
    <link href="/2020/11/29/leetcode-%E8%B7%B3%E6%B0%B4%E6%9D%BF/"/>
    <url>/2020/11/29/leetcode-%E8%B7%B3%E6%B0%B4%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="跳水板拼凑"><a href="#跳水板拼凑" class="headerlink" title="跳水板拼凑"></a>跳水板拼凑</h1><p>题目:有两块板子，长度为x和y，假设有k块，输出所有可能的拼凑长度，例如x=1,y=2,k=3，输出[3,4,5,6]</p><p>本题可看成首项为k<em>x，末项为k</em>y，公差为y-x的等差数列，每用长的替换短的，都是加一次公差，项数为k+1.</p><p>代码如下:</p><pre><code class="hljs java">Public <span class="hljs-keyword">int</span> [] result(<span class="hljs-keyword">int</span> shorter,<span class="hljs-keyword">int</span> longer,<span class="hljs-keyword">int</span> k)&#123;    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">if</span>(shorter==longer)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;shorter*k&#125;;    &#125;    <span class="hljs-keyword">int</span>[] ans=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k+<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> sx = k*shorter;    <span class="hljs-keyword">int</span> delta = longer-shorter;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;=k;i++)&#123;        ans[i]=sx+i*delta;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树总结</title>
    <link href="/2020/11/28/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/2020/11/28/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote><p>什么是二叉查找树（BST）？</p><ol><li><p><strong>左</strong>子树上所有结点的值均<strong>小于或等于</strong>它的根结点的值</p></li><li><p><strong>右</strong>子树上所有结点的值均<strong>大于或等于</strong>它的根结点的值。</p></li><li><p>左、右子树也分别为二叉排序树。</p><p>基于二分查找建树。但存在插入之后节点不平衡情况，由此引入红黑树。</p></li></ol></blockquote><p>红黑树是一种自平衡的二叉查找树，其具有如下特性：</p><ol><li>节点是红色或黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点（NIL节点）。</li><li>每个红色节点的两个子节点都是黑色。即从叶子到根不可能有两个连续的红色节点</li><li>从任意节点到其每个叶子的所有路径都包含相同数目黑色节点。</li></ol><p>典型红黑树如图：</p><p><img src="/img/hongheishu.png"> </p><p>由上述构建规则限制，保证了红黑树从根到叶子的最长路径不会超过最短路径的2倍。</p><h2 id="红黑树的调整"><a href="#红黑树的调整" class="headerlink" title="红黑树的调整"></a>红黑树的调整</h2><p>当插入和删除节点时，红黑树规则会被打破，此时要对其进行调整，以满足条件。调整有两种方法：<strong>变色</strong>和<strong>旋转</strong>，而旋转又分为左旋转和右旋转。</p><h3 id="红黑树的左旋和右旋"><a href="#红黑树的左旋和右旋" class="headerlink" title="红黑树的左旋和右旋"></a>红黑树的左旋和右旋</h3><p>左旋即<strong>逆时针</strong>旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子，如图：</p><p><img src="/img/hongheishuzuoxuan.png"></p><p>右旋即<strong>顺时针</strong>旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。如图：</p><p><img src="/img/hongheishuyouxuan.png"></p><p> 实际使用中，变色和旋转视情况混合使用。</p><h3 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h3><p>在JDK的集合类TreeMap和TreeSet底层都是红黑树实现。在Java8中，HashMap也用到了红黑树.</p>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对偶</title>
    <link href="/2020/11/27/%E5%AF%B9%E5%81%B6/"/>
    <url>/2020/11/27/%E5%AF%B9%E5%81%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="不定期更新的闪耀时刻"><a href="#不定期更新的闪耀时刻" class="headerlink" title="不定期更新的闪耀时刻"></a>不定期更新的闪耀时刻</h1><p>南风过境/梦至西洲</p><p>三山时春/四水常在</p><p>扁舟子/明月楼</p><p>轻云蔽月/流风回雪</p><p>花酿酒/水煎茶</p><p>家人闲坐，灯火可亲。</p><p>塞北风沙酒，江南烟雨桥。</p><p>玉在山而草木润，渊生珠而崖不枯。</p><p>冬月新落雪，徐步纳子岁。</p><p>投入亡地然后存，陷入绝处而后生。</p><p>为众人抱薪者，不可使其扼于风雪。</p><p>欢声笑语别枝后，漫天星子正少年。</p><p>大梦谁先觉，平生我自知。</p><p>青天有月来几时，我今停杯一问之。</p><p>长安陌上无穷树，唯有垂杨管别离。</p><p>敬这大争之世，敬这小酌之时。</p><p>虹贯荆卿之心，碧化苌弘之血。</p><p>时日低矮而天下羊白</p><p>水清鱼读月，花静鸟谈天。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java垃圾回收机制</title>
    <link href="/2020/11/27/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/11/27/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>GC虽然已经自动帮我们完成清理，但了解一下java垃圾回收机制，还是对我们性能调优，问题排查等有很大帮助。本文为博主阅读网上资料后做的相关整理。</p><h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><p>1.虚拟机栈：每个方法被执行的同时会创建<strong>栈桢</strong> ，要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机都很明确，此处<strong>不需要进行 GC</strong>。</p><p>2.本地方法栈：虚拟机栈为虚拟机执行 Java 方法时服务，本地方法栈为虚拟机执行本地方法时服务，此处也<strong>不需要进行 GC</strong>。</p><p>3.程序计数器：线程独有。可以看作是当前线程执行的字节码的行号指示器。Java虚拟机的多线程是通过线程轮流切换并分配处理器的时间来完成的。在任何一个时刻，一个处理器只会执行一个线程，如果这个线程被分配的时间片执行完了（线程被挂起），处理器会切换到另外一个线程执行，程序计数器即记录唤醒线程时上次执行到的位置。另外<strong>程序计数器是唯一一个 Java 虚拟机规范中没有规定任何 OOM 情况的区域</strong>。此处也<strong>不需要进行 GC</strong>。</p><p>4.本地内存：即堆外内存，包含元空间和直接内存，JAVA8之后此区域也<strong>不需要进行 GC</strong>。</p><p>5.堆：对象实例和数组都是在堆上分配，GC主要针对这些数据进行回收，<strong>堆是java垃圾回收处理的主要区域</strong>。</p><h1 id="系统垃圾识别"><a href="#系统垃圾识别" class="headerlink" title="系统垃圾识别"></a>系统垃圾识别</h1><p>GC如何判断堆中对象实例等是不是垃圾？</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>为对象添加引用次数属性，被引用一次，即加一。未被引用即为0，代表可被回收。</p><p>但此类无法解决循环引用的问题，在互相被引用的对象要求释放时，因为引用次数不为零，造成无法回收。因此此方法用得较少。</p><h2 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h2><p>利用一个GC Root的对象为起点出发，逐步指向下一个可达的节点，直至所有节点遍历完毕，不在生成的这个引用链上的对象，即被判断为垃圾，会被GC回收。</p><p>另外，不是a, b 对象可回收，就一定会被回收。对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收。且<strong>finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收。</strong></p><blockquote><p>GC Root是什么？哪些对象可作为GC Root？</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul></blockquote><h1 id="垃圾回收主要方法"><a href="#垃圾回收主要方法" class="headerlink" title="垃圾回收主要方法"></a>垃圾回收主要方法</h1><p>通过可达性算法识别了哪些数据是垃圾，如何对垃圾进行回收？主要有以下三种方法。</p><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><ol><li><p>根据可达性算法标记出所有的可回收对象</p></li><li><p>对可回收对象进行回收</p></li></ol><p>此种算法回收之后会造成很多零碎的小内存，不能满足连续内存的需要</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ol><li><p>将堆分为两块区域,A,B,区域A分配对象，B不分配对象</p></li><li><p>对A使用标记法把存活的对象都标记出来，并将它们复制到区域B</p></li><li><p>把A中对象全部清理释放空间</p></li></ol><p>此方法解决了内存碎片的问题，缺点是堆空间大小利用率大大降低，复制也有资源浪费。</p><h2 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h2><ol><li><p>根据可达性算法标记出所有的可回收对象</p></li><li><p>对标记对象进行整理，将所有存活对象都往一端移动，紧密排列</p></li><li><p>清除掉另一端所有非存活对象</p></li></ol><h1 id="当前垃圾回收器对比"><a href="#当前垃圾回收器对比" class="headerlink" title="当前垃圾回收器对比"></a>当前垃圾回收器对比</h1><p>说完了垃圾回收的方法论，到了垃圾回收器就是内存回收的具体实现了，当前垃圾回收器按使用时期分为如下几类：</p><blockquote><p>JVM中的堆，一般分为三部分：新生代，老年代，永久代（JAVA8永久代移除，被元空间取代）</p><p>1.何为新生代？</p><p>主要用来存放新生对象，一般占堆空间的三分之一空间，会频繁创建对象，频繁触发GC进行垃圾回收。</p><p>新生代又分为三个区： Eden区、ServivorFrom、ServivorTo。</p><p>Eden区：Java新对象的出生地，当此区内存不够时即触发GC，对新生代区进行一次垃圾回收。</p><p>ServivorTo：保留一次GC过程中的幸存者</p><p>ServivorFrom：上一次GC的幸存者，作为本次GC的被扫描者。</p><p>本区GC一般采用复制算法。</p><p>2.何为老年代？</p><p>当新生代无法找到足够大连续空间给新创建的较大对象时，会在老年代触发GC，一般采用标记清除算法。当老年代也没有空间时，会抛出OOM异常。</p></blockquote><h2 id="新生代回收器"><a href="#新生代回收器" class="headerlink" title="新生代回收器"></a>新生代回收器</h2><p>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge。</p><h2 id="老年代回收器"><a href="#老年代回收器" class="headerlink" title="老年代回收器"></a>老年代回收器</h2><p>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</p><blockquote><p>新生代回收器和老年代回收器一般配合使用，共同完成JVM中GC。</p><p>还有一个驾驭一切的垃圾回收器，在新生代，老年代都能使用，即G1。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>垃圾回收机制回收JVM堆内存里的对象空间,不负责回收栈内存数据。</li><li>对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。</li><li>垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。</li><li>可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。</li><li>现在的JVM有多种垃圾回收实现算法，表现各异。</li><li>垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。</li><li>我们可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2020/11/26/Hashmap/"/>
    <url>/2020/11/26/Hashmap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是由数组和链表组合构成的数据结构，数组插入键值对，当遇到哈希值相等的节点时，即在该节点上形成链表。当新的节点插入链表时，java8之前是头插法，java8之后变为尾插法，主要防止哈希表扩容时，头插法易形成循环链表。</p><h1 id="为何JAVA8之后改为尾插法？"><a href="#为何JAVA8之后改为尾插法？" class="headerlink" title="为何JAVA8之后改为尾插法？"></a>为何JAVA8之后改为尾插法？</h1><p>首先来看看HashMap的扩容机制：</p><blockquote><p>数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize.</p><p>一般有两个因素：Capacity–HashMap当前长度       LoadFactor–负载因子，默认值0.75f</p><p>即假设当前的容量大小为100，当存进第76个元素的时候，判断发现需要对哈希表进行resize。</p></blockquote><p>具体扩容分为两步进行：</p><p>  <strong>扩容</strong>：创建一个新的空数组，长度是原数组的2倍</p><p>  <strong>rehash</strong>：遍历原数组，把所有节点重新Hash到新数组</p><blockquote><p>为何要重新hash节点插入？直接复制更快？</p><p>因长度扩容之后，数组长度改变，Hash的规则也会随之改变</p></blockquote><p>具体到为什么改为尾插法更好，使用头插法，容量为2的容器，某一节点上链表A-B-C在不同线程扩容插入A,B,C时，可能会形成B-A-B的回环，而使用尾插不会改变链表上的顺序，扩容时即不会出现链表成环问题。由此JAVA8不会出现像JAVA7在多线程操作哈希表时的死循环问题。</p><p>但这并不说明JAVA8可以任意把哈希表使用在多线程中，通过源码可知put/get方法均没有加同步锁，还是无法保证上一秒put的值，下一秒get还是原值，即线程安全还是无法保证。</p><blockquote><p>哈希表的默认初始化长度是16        为经验值</p></blockquote><h1 id="为何重写equals方法要重写hashCode方法？"><a href="#为何重写equals方法要重写hashCode方法？" class="headerlink" title="为何重写equals方法要重写hashCode方法？"></a>为何重写equals方法要重写hashCode方法？</h1><p>java中所有的对象都是继承于Object类，而Ojbect类中有两个比较两个对象是否相等的方法：equals和hashCode。</p><p>而哈希表找到数组同一节点上的链表时，使用equals比较链表上不同的值，也就是说我们一定要对hashCode进行重写，以保证<strong>相同的对象返回相同的hash值，不同的对象返回不同的hash值</strong>。</p><h1 id="HashMap为何是线程不安全的"><a href="#HashMap为何是线程不安全的" class="headerlink" title="HashMap为何是线程不安全的"></a>HashMap为何是线程不安全的</h1><h2 id="jdk1-7中HashMap"><a href="#jdk1-7中HashMap" class="headerlink" title="jdk1.7中HashMap"></a>jdk1.7中HashMap</h2><p>原因一：扩容造成死循环</p><p>在对哈希表进行扩容时，扩容函数将原数据转移到新表中，也会使用头插法，造成链表顺序翻转，多线程情况下这里是形成死循环的关键点。</p><p>原因二：扩容造成数据丢失</p><p>在扩容时，也可能造成数据丢失，数据指向自己，形成自环</p><h2 id="jdk1-8中的HashMap"><a href="#jdk1-8中的HashMap" class="headerlink" title="jdk1.8中的HashMap"></a>jdk1.8中的HashMap</h2><p>在jdk1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，因此不会出现环形链表的情况，但是在多线程的情况下仍然不安全。诸如不同线程的put相互覆盖的情况。</p><h1 id="如何处理HashMap在线程不安全的情况"><a href="#如何处理HashMap在线程不安全的情况" class="headerlink" title="如何处理HashMap在线程不安全的情况"></a>如何处理HashMap在线程不安全的情况</h1><p>一般使用<strong>HashTable</strong>或者<strong>CurrentHashMap</strong>。</p><blockquote><p>虽然Hashtable和HashMap相比是线程安全的，但其在对数据操作时都会上锁，存在效率问题。另外<strong>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null</strong>。</p></blockquote><h1 id="ConcurrentHashMap如何保证线程安全？"><a href="#ConcurrentHashMap如何保证线程安全？" class="headerlink" title="ConcurrentHashMap如何保证线程安全？"></a>ConcurrentHashMap如何保证线程安全？</h1><p>ConcurrentHashMap的存值put步骤如下：</p><ol><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p></li></ol><p>ConcurrentHashMap的取值get步骤如下：</p><ol><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ol><h1 id="何为CAS，何为自旋？"><a href="#何为CAS，何为自旋？" class="headerlink" title="何为CAS，何为自旋？"></a>何为CAS，何为自旋？</h1><p>CAS 是乐观锁的一种实现方式，为一种轻量级的锁，认为并发操作并不总会发生。</p><p>具体流程为：线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p><p>但其不能检测ABA问题，即A被某线程修改为B，再被某线程修改回A。乐观锁CAS无法检测。</p><h1 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h1><h1 id="synchronized锁升级策略"><a href="#synchronized锁升级策略" class="headerlink" title="synchronized锁升级策略"></a>synchronized锁升级策略</h1>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《九零》（外两首）</title>
    <link href="/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/"/>
    <url>/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>​                        <strong>《九零》</strong></p><p>哨响冬末三九天，心系楚地八方援。</p><p>才笑九零纨绔子，挑灯提剑奔在前。</p><p>欲使天下除病事，敢为家国争人先。</p><p>满腔抱负今犹在，我辈英才正少年。</p><hr><p>才备腊酒留家宴，满城闭户锁门帘。</p><p>岁末不知春尚早，风将吹落谁家檐？</p><p>白衣同往御风雪，万民共载世多贤。</p><p>但看春光明媚去，家人闲坐笑谈天</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--判断回文数</title>
    <link href="/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目：判断一个数是否是回文数，12321是，但负数肯定不是，简单来说，排除负数后，判断整数反转后是否等于自身即可</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">boolean</span> <span class="hljs-title">huiwen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;       <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;       <span class="hljs-keyword">int</span> copyx=x,reverse=<span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span>(copyx!=<span class="hljs-number">0</span>)&#123;           reverse=reverse*<span class="hljs-number">10</span>+copyx%<span class="hljs-number">10</span>;           copyx/=<span class="hljs-number">10</span>;       &#125;       <span class="hljs-keyword">return</span> x==reverse;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--整数反转</title>
    <link href="/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>题目：将整数按位反转，注意若反转后数溢出则返回0</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(;x!=<span class="hljs-number">0</span>;x/=<span class="hljs-number">10</span>)        res = res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;    <span class="hljs-keyword">return</span> res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE?<span class="hljs-number">0</span>;(<span class="hljs-keyword">int</span>) res;&#125;循环部分等价于    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;        res=res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;        x=x/<span class="hljs-number">10</span>;    &#125;</code></pre><p><strong>Integer.MAX_VALUE和Integer.MIN_VALUE分别是整数int的最大和最小值</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--罗马数字转换</title>
    <link href="/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>题目：将罗马数字字符串转换为数字，当小字符在大字符前的时候，结果为大数减小数，如IV=4,IV=9</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">romantoInt</span><span class="hljs-params">(String s)</span></span>&#123;    Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>);    map.put(<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>);    map.put(<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>);    map.put(<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>);    map.put(<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>);    map.put(<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>);    map.put(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>);    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span> sum = map.get(s.charAt(len-<span class="hljs-number">1</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;        <span class="hljs-keyword">if</span>(map.get(s.charAt(i))&lt;map.get(s.charAt(i+!)))&#123;            sum=sum-map.get(s.charAt(i));        &#125;<span class="hljs-keyword">else</span>        &#123;            sum=sum+map.get(s.charAt(i));        &#125;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--两数求和</title>
    <link href="/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <url>/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目：两数求和返回下标，例如[2,7,11,15],目标值target=9，结果返回[0,1]</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"> Public <span class="hljs-keyword">int</span> [] towsum(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)&#123; <span class="hljs-keyword">int</span> len = nums.length;​HashMap&lt;Integer,Integer&gt; map= <span class="hljs-keyword">new</span> HashMap&lt;&gt;();​<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;++i)&#123;​<span class="hljs-keyword">final</span> Integer value = map.get(nums[i]);​<span class="hljs-keyword">if</span>(value!=<span class="hljs-keyword">null</span>)&#123;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;value,i&#125;;​&#125;​map.put(target-nums[i],i);​&#125;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p><strong>使用哈希表，键存target-nums[i]差值，值存相对应下标，若遍历时已存在，则返回目标对应值和当前下标</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图神经网络综述</title>
    <link href="/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/"/>
    <url>/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="图神经网络综述"><a href="#图神经网络综述" class="headerlink" title="图神经网络综述"></a>图神经网络综述</h1><h2 id="GNN简介与起源"><a href="#GNN简介与起源" class="headerlink" title="GNN简介与起源"></a>GNN简介与起源</h2><h2 id="GNN与传统NN区别"><a href="#GNN与传统NN区别" class="headerlink" title="GNN与传统NN区别"></a>GNN与传统NN区别</h2><h2 id="GNN分类"><a href="#GNN分类" class="headerlink" title="GNN分类"></a>GNN分类</h2><h2 id="GNN模型概览"><a href="#GNN模型概览" class="headerlink" title="GNN模型概览"></a>GNN模型概览</h2><h3 id="Original-GNN"><a href="#Original-GNN" class="headerlink" title="Original GNN"></a>Original GNN</h3><h3 id="GNN-Variants"><a href="#GNN-Variants" class="headerlink" title="GNN Variants"></a>GNN Variants</h3><h3 id="GNN的General-Framework"><a href="#GNN的General-Framework" class="headerlink" title="GNN的General Framework"></a>GNN的General Framework</h3><h2 id="GNN应用"><a href="#GNN应用" class="headerlink" title="GNN应用"></a>GNN应用</h2><h3 id="结构化场景"><a href="#结构化场景" class="headerlink" title="结构化场景"></a>结构化场景</h3><h3 id="非结构化场景"><a href="#非结构化场景" class="headerlink" title="非结构化场景"></a>非结构化场景</h3><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>（以上部分按照[Graph Neural Networks: A Review of Methods and Applications]进行编排书写，后面按照其参考文献逐步抽取）</p><hr><hr><h2 id="GNN模型论文"><a href="#GNN模型论文" class="headerlink" title="GNN模型论文"></a>GNN模型论文</h2><blockquote><p>此部分按照[The Graph Neural Network Model]综述论文书写，对GNN模型有较为详细介绍</p></blockquote><h2 id="GCN模型论文"><a href="#GCN模型论文" class="headerlink" title="GCN模型论文"></a>GCN模型论文</h2><blockquote><p>此部分按照[Semi-Supervised Classification with Graph Convolutional Networks]文章介绍书写，另外还有一篇博客可学习<a href="http://xtf615.com/2019/02/24/gcn/">http://xtf615.com/2019/02/24/gcn/</a></p></blockquote><h3 id="GCN演变"><a href="#GCN演变" class="headerlink" title="GCN演变"></a>GCN演变</h3><h3 id="详细GCN论文模型"><a href="#详细GCN论文模型" class="headerlink" title="详细GCN论文模型"></a>详细GCN论文模型</h3><h2 id="DCNN模型论文"><a href="#DCNN模型论文" class="headerlink" title="DCNN模型论文"></a>DCNN模型论文</h2><blockquote><p>此部分按照[Diffusion-Convolutional Neural Networks]的模型发展进行描述</p></blockquote><h2 id="Tree-LSTM模型论文"><a href="#Tree-LSTM模型论文" class="headerlink" title="Tree-LSTM模型论文"></a>Tree-LSTM模型论文</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="关于不动点定理"><a href="#关于不动点定理" class="headerlink" title="关于不动点定理"></a>关于不动点定理</h3><h3 id="关于递归求导"><a href="#关于递归求导" class="headerlink" title="关于递归求导"></a>关于递归求导</h3><h3 id="关于切比雪夫多项式"><a href="#关于切比雪夫多项式" class="headerlink" title="关于切比雪夫多项式"></a>关于切比雪夫多项式</h3><h3 id="关于图Fourier变换"><a href="#关于图Fourier变换" class="headerlink" title="关于图Fourier变换"></a>关于图Fourier变换</h3><h3 id="关于RNN系列模型"><a href="#关于RNN系列模型" class="headerlink" title="关于RNN系列模型"></a>关于RNN系列模型</h3><h2 id="灵光"><a href="#灵光" class="headerlink" title="灵光"></a>灵光</h2>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
      <tag>GCN</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
