<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hashmap</title>
    <link href="/2020/11/26/Hashmap/"/>
    <url>/2020/11/26/Hashmap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是由数组和链表组合构成的数据结构，数组插入键值对，当遇到哈希值相等的节点时，即在该节点上形成链表。当新的节点插入链表时，java8之前是头插法，java8之后变为尾插法，主要防止哈希表扩容时，头插法易形成循环链表。</p><h1 id="为何JAVA8之后改为尾插法？"><a href="#为何JAVA8之后改为尾插法？" class="headerlink" title="为何JAVA8之后改为尾插法？"></a>为何JAVA8之后改为尾插法？</h1><p>首先来看看HashMap的扩容机制：</p><blockquote><p>数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize.</p><p>一般有两个因素：Capacity–HashMap当前长度       LoadFactor–负载因子，默认值0.75f</p><p>即假设当前的容量大小为100，当存进第76个元素的时候，判断发现需要对哈希表进行resize。</p></blockquote><p>具体扩容分为两步进行：</p><p>  <strong>扩容</strong>：创建一个新的空数组，长度是原数组的2倍</p><p>  <strong>rehash</strong>：遍历原数组，把所有节点重新Hash到新数组</p><blockquote><p>为何要重新hash节点插入？直接复制更快？</p><p>因长度扩容之后，数组长度改变，Hash的规则也会随之改变</p></blockquote><p>具体到为什么改为尾插法更好，使用头插法，容量为2的容器，某一节点上链表A-B-C在不同线程扩容插入A,B,C时，可能会形成B-A-B的回环，而使用尾插不会改变链表上的顺序，扩容时即不会出现链表成环问题。由此JAVA8不会出现像JAVA7在多线程操作哈希表时的死循环问题。</p><p>但这并不说明JAVA8可以任意把哈希表使用在多线程中，通过源码可知put/get方法均没有加同步锁，还是无法保证上一秒put的值，下一秒get还是原值，即线程安全还是无法保证。</p><blockquote><p>哈希表的默认初始化长度是16        为经验值</p></blockquote><h1 id="为何重写equals方法要重写hashCode方法？"><a href="#为何重写equals方法要重写hashCode方法？" class="headerlink" title="为何重写equals方法要重写hashCode方法？"></a>为何重写equals方法要重写hashCode方法？</h1><p>java中所有的对象都是继承于Object类，而Ojbect类中有两个比较两个对象是否相等的方法：equals和hashCode。</p><p>而哈希表找到数组同一节点上的链表时，使用equals比较链表上不同的值，也就是说我们一定要对hashCode进行重写，以保证<strong>相同的对象返回相同的hash值，不同的对象返回不同的hash值</strong>。</p><h1 id="HashMap为何是线程不安全的"><a href="#HashMap为何是线程不安全的" class="headerlink" title="HashMap为何是线程不安全的"></a>HashMap为何是线程不安全的</h1><h2 id="jdk1-7中HashMap"><a href="#jdk1-7中HashMap" class="headerlink" title="jdk1.7中HashMap"></a>jdk1.7中HashMap</h2><p>原因一：扩容造成死循环</p><p>在对哈希表进行扩容时，扩容函数将原数据转移到新表中，也会使用头插法，造成链表顺序翻转，多线程情况下这里是形成死循环的关键点。</p><p>原因二：扩容造成数据丢失</p><p>在扩容时，也可能造成数据丢失，数据指向自己，形成自环</p><h2 id="jdk1-8中的HashMap"><a href="#jdk1-8中的HashMap" class="headerlink" title="jdk1.8中的HashMap"></a>jdk1.8中的HashMap</h2><p>在jdk1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，因此不会出现环形链表的情况，但是在多线程的情况下仍然不安全。诸如不同线程的put相互覆盖的情况。</p><h1 id="如何处理HashMap在线程不安全的情况"><a href="#如何处理HashMap在线程不安全的情况" class="headerlink" title="如何处理HashMap在线程不安全的情况"></a>如何处理HashMap在线程不安全的情况</h1><p>一般使用<strong>HashTable</strong>或者<strong>CurrentHashMap</strong>。</p><blockquote><p>虽然Hashtable和HashMap相比是线程安全的，但其在对数据操作时都会上锁，存在效率问题。另外<strong>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null</strong>。</p></blockquote><h1 id="ConcurrentHashMap如何保证线程安全？"><a href="#ConcurrentHashMap如何保证线程安全？" class="headerlink" title="ConcurrentHashMap如何保证线程安全？"></a>ConcurrentHashMap如何保证线程安全？</h1><p>ConcurrentHashMap的存值put步骤如下：</p><ol><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p></li></ol><p>ConcurrentHashMap的取值get步骤如下：</p><ol><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ol><h1 id="何为CAS，何为自旋？"><a href="#何为CAS，何为自旋？" class="headerlink" title="何为CAS，何为自旋？"></a>何为CAS，何为自旋？</h1><p>CAS 是乐观锁的一种实现方式，为一种轻量级的锁，认为并发操作并不总会发生。</p><p>具体流程为：线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p><p>但其不能检测ABA问题，即A被某线程修改为B，再被某线程修改回A。乐观锁CAS无法检测。</p><h1 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h1><h1 id="synchronized锁升级策略"><a href="#synchronized锁升级策略" class="headerlink" title="synchronized锁升级策略"></a>synchronized锁升级策略</h1>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《九零》（外两首）</title>
    <link href="/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/"/>
    <url>/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>​                        <strong>《九零》</strong></p><p>哨响冬末三九天，心系楚地八方援。</p><p>才笑九零纨绔子，挑灯提剑奔在前。</p><p>欲使天下除病事，敢为家国争人先。</p><p>满腔抱负今犹在，我辈英才正少年。</p><hr><p>才备腊酒留家宴，满城闭户锁门帘。</p><p>岁末不知春尚早，风将吹落谁家檐？</p><p>白衣同往御风雪，万民共载世多贤。</p><p>但看春光明媚去，家人闲坐笑谈天</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--判断回文数</title>
    <link href="/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目：判断一个数是否是回文数，12321是，但负数肯定不是，简单来说，排除负数后，判断整数反转后是否等于自身即可</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">boolean</span> <span class="hljs-title">huiwen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;       <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;       <span class="hljs-keyword">int</span> copyx=x,reverse=<span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span>(copyx!=<span class="hljs-number">0</span>)&#123;           reverse=reverse*<span class="hljs-number">10</span>+copyx%<span class="hljs-number">10</span>;           copyx/=<span class="hljs-number">10</span>;       &#125;       <span class="hljs-keyword">return</span> x==reverse;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--整数反转</title>
    <link href="/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>题目：将整数按位反转，注意若反转后数溢出则返回0</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(;x!=<span class="hljs-number">0</span>;x/=<span class="hljs-number">10</span>)        res = res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;    <span class="hljs-keyword">return</span> res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE?<span class="hljs-number">0</span>;(<span class="hljs-keyword">int</span>) res;&#125;循环部分等价于    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;        res=res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;        x=x/<span class="hljs-number">10</span>;    &#125;</code></pre><p><strong>Integer.MAX_VALUE和Integer.MIN_VALUE分别是整数int的最大和最小值</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--罗马数字转换</title>
    <link href="/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>题目：将罗马数字字符串转换为数字，当小字符在大字符前的时候，结果为大数减小数，如IV=4,IV=9</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">romantoInt</span><span class="hljs-params">(String s)</span></span>&#123;    Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>);    map.put(<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>);    map.put(<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>);    map.put(<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>);    map.put(<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>);    map.put(<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>);    map.put(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>);    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span> sum = map.get(s.charAt(len-<span class="hljs-number">1</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;        <span class="hljs-keyword">if</span>(map.get(s.charAt(i))&lt;map.get(s.charAt(i+!)))&#123;            sum=sum-map.get(s.charAt(i));        &#125;<span class="hljs-keyword">else</span>        &#123;            sum=sum+map.get(s.charAt(i));        &#125;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--两数求和</title>
    <link href="/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <url>/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目：两数求和返回下标，例如[2,7,11,15],目标值target=9，结果返回[0,1]</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"> Public <span class="hljs-keyword">int</span> [] towsum(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)&#123; <span class="hljs-keyword">int</span> len = nums.length;​HashMap&lt;Integer,Integer&gt; map= <span class="hljs-keyword">new</span> HashMap&lt;&gt;();​<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;++i)&#123;​<span class="hljs-keyword">final</span> Integer value = map.get(nums[i]);​<span class="hljs-keyword">if</span>(value!=<span class="hljs-keyword">null</span>)&#123;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;value,i&#125;;​&#125;​map.put(target-nums[i],i);​&#125;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p><strong>使用哈希表，键存target-nums[i]差值，值存相对应下标，若遍历时已存在，则返回目标对应值和当前下标</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图神经网络综述</title>
    <link href="/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/"/>
    <url>/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="图神经网络综述"><a href="#图神经网络综述" class="headerlink" title="图神经网络综述"></a>图神经网络综述</h1><h2 id="GNN简介与起源"><a href="#GNN简介与起源" class="headerlink" title="GNN简介与起源"></a>GNN简介与起源</h2><h2 id="GNN与传统NN区别"><a href="#GNN与传统NN区别" class="headerlink" title="GNN与传统NN区别"></a>GNN与传统NN区别</h2><h2 id="GNN分类"><a href="#GNN分类" class="headerlink" title="GNN分类"></a>GNN分类</h2><h2 id="GNN模型概览"><a href="#GNN模型概览" class="headerlink" title="GNN模型概览"></a>GNN模型概览</h2><h3 id="Original-GNN"><a href="#Original-GNN" class="headerlink" title="Original GNN"></a>Original GNN</h3><h3 id="GNN-Variants"><a href="#GNN-Variants" class="headerlink" title="GNN Variants"></a>GNN Variants</h3><h3 id="GNN的General-Framework"><a href="#GNN的General-Framework" class="headerlink" title="GNN的General Framework"></a>GNN的General Framework</h3><h2 id="GNN应用"><a href="#GNN应用" class="headerlink" title="GNN应用"></a>GNN应用</h2><h3 id="结构化场景"><a href="#结构化场景" class="headerlink" title="结构化场景"></a>结构化场景</h3><h3 id="非结构化场景"><a href="#非结构化场景" class="headerlink" title="非结构化场景"></a>非结构化场景</h3><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>（以上部分按照[Graph Neural Networks: A Review of Methods and Applications]进行编排书写，后面按照其参考文献逐步抽取）</p><hr><hr><h2 id="GNN模型论文"><a href="#GNN模型论文" class="headerlink" title="GNN模型论文"></a>GNN模型论文</h2><blockquote><p>此部分按照[The Graph Neural Network Model]综述论文书写，对GNN模型有较为详细介绍</p></blockquote><h2 id="GCN模型论文"><a href="#GCN模型论文" class="headerlink" title="GCN模型论文"></a>GCN模型论文</h2><blockquote><p>此部分按照[Semi-Supervised Classification with Graph Convolutional Networks]文章介绍书写，另外还有一篇博客可学习<a href="http://xtf615.com/2019/02/24/gcn/">http://xtf615.com/2019/02/24/gcn/</a></p></blockquote><h3 id="GCN演变"><a href="#GCN演变" class="headerlink" title="GCN演变"></a>GCN演变</h3><h3 id="详细GCN论文模型"><a href="#详细GCN论文模型" class="headerlink" title="详细GCN论文模型"></a>详细GCN论文模型</h3><h2 id="DCNN模型论文"><a href="#DCNN模型论文" class="headerlink" title="DCNN模型论文"></a>DCNN模型论文</h2><blockquote><p>此部分按照[Diffusion-Convolutional Neural Networks]的模型发展进行描述</p></blockquote><h2 id="Tree-LSTM模型论文"><a href="#Tree-LSTM模型论文" class="headerlink" title="Tree-LSTM模型论文"></a>Tree-LSTM模型论文</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="关于不动点定理"><a href="#关于不动点定理" class="headerlink" title="关于不动点定理"></a>关于不动点定理</h3><h3 id="关于递归求导"><a href="#关于递归求导" class="headerlink" title="关于递归求导"></a>关于递归求导</h3><h3 id="关于切比雪夫多项式"><a href="#关于切比雪夫多项式" class="headerlink" title="关于切比雪夫多项式"></a>关于切比雪夫多项式</h3><h3 id="关于图Fourier变换"><a href="#关于图Fourier变换" class="headerlink" title="关于图Fourier变换"></a>关于图Fourier变换</h3><h3 id="关于RNN系列模型"><a href="#关于RNN系列模型" class="headerlink" title="关于RNN系列模型"></a>关于RNN系列模型</h3><h2 id="灵光"><a href="#灵光" class="headerlink" title="灵光"></a>灵光</h2>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
      <tag>GCN</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
